<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Actors
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->


  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f actors\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><a href="../../docs/proofs/"><strong>Proofs</strong></a></p>

<ul>
<li><a href="../../docs/zigzag-porep/">Proof-of-Replication</a>

<ul>
<li><a href="../../docs/zigzag-commitments/">ZigZag Commitments</a></li>
<li><a href="../../docs/zigzag-circuit/">Circuit</a></li>
</ul></li>
<li><a href="../../docs/proof-of-spacetime/">Proof-of-Spacetime</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Actors
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="filecoin-state-machine-actors">Filecoin State Machine Actors</h1>

<p>Any implementations of the Filecoin actors must be exactly byte for byte compatible with the go-filecoin actor implementations. The pseudocode below tries to capture the important logic, but capturing all the detail would require embedding exactly the code from go-filecoin, so for now, its simply informative pseudocode. The algorithms below are correct, and all implementations much match it (including go-filecoin), but details omitted from here should be looked for in the go-filecoin code.</p>

<p>This spec describes a set of actors that operate within the <a href="../state-machine">Filecoin State Machine</a>. All types are defined in <a href="../data-structures#basic-type-encodings">the basic type encoding spec</a>.</p>

<h2 id="actor-state">Actor State</h2>

<p>Each actor type defines their own structure for storing their state. We
represent each with an IPLD schema at the beginning of each actor section in
this document.</p>

<h2 id="system-actors">System Actors</h2>

<p>Some state machine actors are &lsquo;system&rsquo; actors that get instantiated in the genesis block, and have their IDs allocated at that point.</p>

<table>
<thead>
<tr>
<th>ID</th>
<th>Actor</th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>InitActor</td>
<td>Network Init</td>
</tr>

<tr>
<td>1</td>
<td>AccountActor</td>
<td>Network Treasury</td>
</tr>

<tr>
<td>2</td>
<td>StorageMarketActor</td>
<td>Filecoin Storage Market</td>
</tr>

<tr>
<td>99</td>
<td>AccountActor</td>
<td>Burnt Funds</td>
</tr>
</tbody>
</table>

<h2 id="built-in-actors">Built In Actors</h2>

<h3 id="init-actor">Init Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;init&quot;&gt;</code></li>
</ul>

<p>The init actor is responsible for creating new actors on the filecoin network. This is a built-in actor and cannot be replicated. In the future, this actor will be responsible for loading new code into the system (for user programmable actors). ID allocation for user instantiated actors starts at 100. This means that <code>NextID</code> will initially be set to 100.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> InitActorState struct <span class="o">{</span>
    addressMap <span class="o">{</span>Address:ID<span class="o">}</span>&lt;Hamt&gt;
    nextId UInt
<span class="o">}</span></code></pre></div>
<h4 id="methods">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Constructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>Exec</code></td>
<td>2</td>
</tr>

<tr>
<td><code>GetIdForAddress</code></td>
<td>3</td>
</tr>
</tbody>
</table>

<h4 id="constructor"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> InitConstructor struct <span class="o">{</span>
<span class="o">}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<h4 id="exec"><code>Exec</code></h4>

<p>This method is the core of the <code>Init Actor</code>. It handles instantiating new actors and assigning them their IDs.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Exec struct <span class="o">{</span>
    <span class="c1">## Reference to the location at which the code of the actor to create is stored.</span>
    code <span class="p">&amp;</span>Code
    <span class="c1">## Parameters passed to the constructor of the actor.</span>
    params ActorMethod
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">code</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">ActorMethod</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="c1">// Get the actor ID for this actor.
</span><span class="c1"></span>    <span class="nx">actorID</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">NextID</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">NextID</span><span class="o">++</span>

    <span class="c1">// Make sure that only the actors defined in the spec can be launched.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">IsBuiltinActor</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch actor instance that is not a builtin actor&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Ensure that singeltons can be only launched once.
</span><span class="c1"></span>    <span class="c1">// TODO: do we want to enforce this? If so how should actors be marked as such?
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">IsSingletonActor</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch another actor of this type&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// This generates a unique address for this actor that is stable across message
</span><span class="c1"></span>    <span class="c1">// reordering
</span><span class="c1"></span>    <span class="c1">// TODO: where do `creator` and `nonce` come from?
</span><span class="c1"></span>    <span class="nx">addr</span> <span class="o">:=</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span><span class="p">,</span> <span class="nx">nonce</span><span class="p">)</span>

    <span class="c1">// Set up the actor itself
</span><span class="c1"></span>    <span class="nx">actor</span> <span class="o">:=</span> <span class="nx">Actor</span><span class="p">{</span>
        <span class="nx">Code</span><span class="p">:</span>    <span class="nx">code</span><span class="p">,</span>
        <span class="nx">Balance</span><span class="p">:</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
        <span class="nx">Head</span><span class="p">:</span>    <span class="kc">nil</span><span class="p">,</span>
        <span class="nx">Nonce</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// The call to the actors constructor will set up the initial state
</span><span class="c1"></span>    <span class="c1">// from the given parameters, setting `actor.Head` to a new value when successfull.
</span><span class="c1"></span>    <span class="c1">// TODO: can constructors fail?
</span><span class="c1"></span>    <span class="nx">actor</span><span class="p">.</span><span class="nf">Constructor</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>

    <span class="nx">VM</span><span class="p">.</span><span class="nx">GlobalState</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">actorID</span><span class="p">,</span> <span class="nx">actor</span><span class="p">)</span>

    <span class="c1">// Store the mapping of address to actor ID.
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorID</span>

    <span class="k">return</span> <span class="nx">addr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IsSingletonActor</span><span class="p">(</span><span class="nx">code</span> <span class="nx">Cid</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">code</span> <span class="o">==</span> <span class="nx">StorageMarketActor</span> <span class="o">||</span> <span class="nx">code</span> <span class="o">==</span> <span class="nx">InitActor</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TODO: find a better home for this logic
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">VM</span> <span class="nx">VM</span><span class="p">)</span> <span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">nonce</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">NewActorAddress</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="nx">creator</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">nonce</span><span class="p">.</span><span class="nf">BigEndianBytes</span><span class="p">()))</span>
<span class="p">}</span></code></pre></div>
<h4 id="getidforaddress"><code>GetIdForAddress</code></h4>

<p>This method allows for fetching the corresponding ID of a given Address</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetIdForAddress struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetIdForAddress</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">Fault</span><span class="p">(</span><span class="s">&#34;unknown address&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">id</span>
<span class="p">}</span></code></pre></div>
<h3 id="account-actor">Account Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;account&quot;&gt;</code></li>
</ul>

<p>The Account actor is the actor used for normal keypair backed accounts on the filecoin network.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> AccountActorState struct <span class="o">{</span>
    address Address
<span class="o">}</span></code></pre></div>
<h4 id="methods-1">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>AccountConstructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>GetAddress</code></td>
<td>2</td>
</tr>
</tbody>
</table>

<pre><code>type AccountConstructor struct {
}
</code></pre>

<h4 id="getaddress"><code>GetAddress</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetAddress struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetAddress</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">address</span>
<span class="p">}</span></code></pre></div>
<h3 id="storage-market-actor">Storage Market Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;smarket&quot;&gt;</code></li>
</ul>

<p>The storage market actor is the central point for the Filecoin storage market. It is responsible for registering new miners to the system, and maintaining the power table. The Filecoin storage market is a singleton that lives at a specific well-known address.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMarketActorState struct <span class="o">{</span>
    miners <span class="o">{</span>Address:Null<span class="o">}</span>&lt;Hamt&gt;
    totalStorage BytesAmount
<span class="o">}</span></code></pre></div>
<h4 id="methods-2">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>StorageMarketConstructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>CreateStorageMiner</code></td>
<td>2</td>
</tr>

<tr>
<td><code>SlashConsensusFault</code></td>
<td>3</td>
</tr>

<tr>
<td><code>UpdateStorage</code></td>
<td>4</td>
</tr>

<tr>
<td><code>GetTotalStorage</code></td>
<td>5</td>
</tr>

<tr>
<td><code>PowerLookup</code></td>
<td>6</td>
</tr>

<tr>
<td><code>IsMiner</code></td>
<td>7</td>
</tr>

<tr>
<td><code>StorageCollateralForSize</code></td>
<td>8</td>
</tr>
</tbody>
</table>

<h4 id="constructor-1"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMarketConstructor struct <span class="o">{}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<h4 id="createstorageminer"><code>CreateStorageMiner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> CreateStorageMiner struct <span class="o">{</span>
    worker Address
    sectorSize BytesAmount
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CreateStorageMiner</span><span class="p">(</span><span class="nx">worker</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">owner</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">SupportedSectorSize</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Unsupported sector size&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">newminer</span> <span class="o">:=</span> <span class="nx">InitActor</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">MinerActorCodeCid</span><span class="p">,</span> <span class="nf">EncodeParams</span><span class="p">(</span><span class="nx">worker</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">pledge</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pid</span><span class="p">))</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">newminer</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">newminer</span>
<span class="p">}</span></code></pre></div>
<h4 id="slashconsensusfault"><code>SlashConsensusFault</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SlashConsensusFault struct <span class="o">{</span>
    block1 <span class="p">&amp;</span>Block
    block2 <span class="p">&amp;</span>Block
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">shouldSlash</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span> <span class="nx">BlockHeader</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// First slashing condition, blocks have the same ticket round
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">sameTicketRound</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="c1">// Second slashing condition, miner ignored own block when mining
</span><span class="c1"></span>    <span class="c1">// Case A: block2 could have been in block1&#39;s parent set but is not
</span><span class="c1"></span>    <span class="nx">block1ParentTipSet</span> <span class="o">:=</span> <span class="nf">parentOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">block1Parent</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block1ParentTipSet</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="nx">block2</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block1ParentTipSet</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="o">==</span> <span class="nx">block2</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="c1">// Case B: block1 could have been in block2&#39;s parent set but is not
</span><span class="c1"></span>    <span class="nx">block2ParentTipSet</span> <span class="o">:=</span> <span class="nf">parentOf</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">block2Parent</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block2ParentTipSet</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="nx">block1</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block2ParentTipSet</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="o">==</span> <span class="nx">block1</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SlashConsensusFault</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span> <span class="nx">BlockHeader</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">block1</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nf">ValidSignature</span><span class="p">(</span><span class="nx">block2</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid blocks&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;blocks must be from the same miner&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// see the &#34;Consensus Faults&#34; section of the faults spec (faults.md)
</span><span class="c1"></span>    <span class="c1">// for details on these slashing conditions.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">shouldSlash</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;blocks do not prove a slashable offense&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">miner</span> <span class="o">:=</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span>

    <span class="c1">// TODO: Some of the slashed collateral should be paid to the slasher
</span><span class="c1"></span>
    <span class="c1">// Burn all of the miners collateral
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nf">BurnCollateral</span><span class="p">()</span>

    <span class="c1">// Remove the miner from the list of network miners
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
    <span class="nx">self</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span><span class="p">)</span>

    <span class="c1">// Now delete the miner (maybe this is a bit harsh, but i&#39;m okay with it for now)
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nf">SelfDestruct</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="updatestorage"><code>UpdateStorage</code></h4>

<p>UpdateStorage is used to update the global power table.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UpdateStorage struct <span class="o">{</span>
    delta BytesAmount
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">delta</span> <span class="nx">BytesAmount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;update storage must only be called by a miner actor&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">TotalStorage</span> <span class="o">+=</span> <span class="nx">delta</span>
<span class="p">}</span></code></pre></div>
<h4 id="gettotalstorage"><code>GetTotalStorage</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetTotalStorage struct <span class="o">{</span>

<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetTotalStorage</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">TotalStorage</span>
<span class="p">}</span></code></pre></div>
<h4 id="powerlookup"><code>PowerLookup</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PowerLookup struct <span class="o">{</span>
    miner Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">PowerLookup</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner not registered with storage market&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">mact</span> <span class="o">:=</span> <span class="nf">LoadMinerActor</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">mact</span><span class="p">.</span><span class="nf">GetPower</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="isminer"><code>IsMiner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> IsMiner struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsMiner</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="storagecollateralforsize"><code>StorageCollateralForSize</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageCollateralForSize struct <span class="o">{</span>
    size UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StorageCollateralforSize</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
    <span class="c1">// TODO:
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h2 id="storage-miner-actor">Storage Miner Actor</h2>

<ul>
<li><p><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;sminer&quot;&gt;</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMinerActorState struct <span class="o">{</span>
<span class="c1">## contains mostly static info about this miner</span>
info <span class="p">&amp;</span>MinerInfo


<span class="c1">## Collateral that is waiting to be withdrawn.</span>
dePledgedCollateral TokenAmount

    <span class="c1">## Time at which the depledged collateral may be withdrawn.</span>
dePledgeTime BlockHeight

    <span class="c1">## All sectors this miner has committed.</span>
sectors <span class="p">&amp;</span>SectorSet

    <span class="c1">## Sectors this miner is currently mining. It is only updated</span>
    <span class="c1">## when a PoSt is submitted (not as each new sector commitment is added).</span>
provingSet <span class="p">&amp;</span>SectorSet

<span class="c1">## Faulty sectors reported since last SubmitPost, up to the current proving period&#39;s challenge time.</span>
currentFaultSet BitField

<span class="c1">## Faults submitted after the current proving period&#39;s challenge time, but before the PoSt for that period</span>
<span class="c1">## is submitted. These become the currentFaultSet when a PoSt is submitted.</span>
nextFaultSet BitField

    <span class="c1">## Sectors reported during the last PoSt submission as being &#39;done&#39;. The collateral</span>
<span class="c1">## for them is still being held until the next PoSt submission in case early sector</span>
<span class="c1">## removal penalization is needed.</span>
nextDoneSet BitField

    <span class="c1">## Deals this miner has been slashed for since the last post submission.</span>
arbitratedDeals <span class="o">{</span>Cid:Null<span class="o">}</span>

    <span class="c1">## Amount of power this miner has.</span>
power UInt

<span class="c1">## List of sectors that this miner was slashed for.</span>
slashedSet optional <span class="p">&amp;</span>SectorSet

<span class="c1">## The height at which this miner was slashed at.</span>
slashedAt optional BlockHeight

<span class="c1">## The amount of storage collateral that is owed to clients, and cannot be used for collateral anymore.</span>
owedStorageCollateral TokenAmount

provingPeriodEnd BlockHeight
<span class="o">}</span>

<span class="nb">type</span> MinerInfo struct <span class="o">{</span>
    <span class="c1">## Account that owns this miner.</span>
<span class="c1">## - Income and returned collateral are paid to this address.</span>
<span class="c1">## - This address is also allowed to change the worker address for the miner.</span>
owner Address

    <span class="c1">## Worker account for this miner.</span>
    <span class="c1">## This will be the key that is used to sign blocks created by this miner, and</span>
    <span class="c1">## sign messages sent on behalf of this miner to commit sectors, submit PoSts, and</span>
    <span class="c1">## other day to day miner activities.</span>
worker Address

<span class="c1">## Libp2p identity that should be used when connecting to this miner.</span>
peerId PeerId

<span class="c1">## Amount of space in each sector committed to the network by this miner.</span>
sectorSize BytesAmount

<span class="o">}</span>

<span class="c1">#### Methods</span>

<span class="p">|</span> Name <span class="p">|</span> Method ID <span class="p">|</span>
<span class="p">|</span>--------<span class="p">|</span>-------------<span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>StorageMinerConstructor<span class="sb">`</span> <span class="p">|</span> <span class="m">1</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>CommitSector<span class="sb">`</span> <span class="p">|</span> <span class="m">2</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>SubmitPost<span class="sb">`</span> <span class="p">|</span> <span class="m">3</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>SlashStorageFault<span class="sb">`</span> <span class="p">|</span> <span class="m">4</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>GetCurrentProvingSet<span class="sb">`</span> <span class="p">|</span> <span class="m">5</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>ArbitrateDeal<span class="sb">`</span> <span class="p">|</span> <span class="m">6</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>DePledge<span class="sb">`</span> <span class="p">|</span> <span class="m">7</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>GetOwner<span class="sb">`</span> <span class="p">|</span> <span class="m">8</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>GetWorkerAddr<span class="sb">`</span> <span class="p">|</span> <span class="m">9</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>GetPower<span class="sb">`</span> <span class="p">|</span> <span class="m">10</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>GetPeerID<span class="sb">`</span> <span class="p">|</span> <span class="m">11</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>GetSectorSize<span class="sb">`</span> <span class="p">|</span> <span class="m">12</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>UpdatePeerID<span class="sb">`</span> <span class="p">|</span> <span class="m">13</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>ChangeWorker<span class="sb">`</span> <span class="p">|</span> <span class="m">14</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>IsSlashed<span class="sb">`</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>IsLate<span class="sb">`</span> <span class="p">|</span> <span class="m">16</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>PaymentVerifyInclusion<span class="sb">`</span> <span class="p">|</span> <span class="m">17</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>PaymentVerifySector<span class="sb">`</span> <span class="p">|</span> <span class="m">18</span> <span class="p">|</span>
<span class="p">|</span> <span class="sb">`</span>AddFaults<span class="sb">`</span> <span class="p">|</span> <span class="m">19</span> <span class="p">|</span>

<span class="c1">#### `Constructor`</span>

Along with the call, the actor must be created with exactly enough filecoin <span class="k">for</span> the collateral necessary <span class="k">for</span> the pledge.

**Parameters**</code></pre></div>
<p>sh</p></li>
</ul>

<p>type StorageMinerConstructor struct {
    worker Address
    owner Address
    sectorSize BytesAmount
    peerId PeerId
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func StorageMinerActor(worker Address, owner Address, sectorSize BytesAmount, pid PeerID) {
    self.info.owner = message.From
    self.info.worker = worker
    self.info.peerID = pid
    self.info.sectorSize = sectorSize</p>

<pre><code>self.sectors = EmptySectorSet()
self.provingSet = EmptySectorSet()
</code></pre>

<p>}</p>

<pre><code>
#### `CommitSector`

**Parameters**

</code></pre>

<p>sh
type CommitSector struct {
    sectorId SectorID
    commD Bytes
    commR Bytes
    commRStar Bytes
    proof SealProof
} representation tuple</p>

<pre><code>
**Algorithm**

&lt;div class=&quot;notices todo&quot; &gt;TODO: ValidatePoRep, EnsureSectorIsUnique, CollateralForSector, Commitment&lt;/div&gt;


</code></pre>

<p>go
func CommitSector(sectorID SectorID, commD, commR, commRStar []byte, proof SealProof) SectorID {
    if !self.ValidatePoRep(self.info.sectorSize, comm, self.info.worker, proof) {
        Fatal(&ldquo;bad proof!&rdquo;)
    }</p>

<pre><code>// make sure the miner isnt trying to submit a pre-existing sector
if !self.EnsureSectorIsUnique(comm) {
    Fatal(&quot;sector already committed!&quot;)
}

// Power of the miner after adding this sector
futurePower = self.power + self.info.sectorSize
collateralRequired = CollateralForPower(futurePower)

if collateralRequired &gt; vm.MyBalance() {
    Fatal(&quot;not enough collateral&quot;)
}

// Note: There must exist a unique index in the miner's sector set for each
// sector ID. The `faults`, `recovered`, and `done` parameters of the
// SubmitPoSt method express indices into this sector set.
miner.Sectors.Add(sectorID, commR, commD)

// if miner is not mining, start their proving period now
// Note: As written here, every miners first PoSt will only be over one sector.
// We could set up a 'grace period' for starting mining that would allow miners
// to submit several sectors for their first proving period. Alternatively, we
// could simply make the 'CommitSector' call take multiple sectors at a time.
//
// Note: Proving period is a function of sector size; small sectors take less
// time to prove than large sectors do. Sector size is selected when pledging.
if miner.ProvingSet.Size() == 0 {
    miner.ProvingSet = miner.Sectors
    miner.ProvingPeriodEnd = chain.Now() + ProvingPeriodDuration(miner.SectorSize)
}
</code></pre>

<p>}</p>

<p>func CollateralForPower(power BytesAmount) TokenAmount {
    availableFil = FakeGlobalMethods.GetAvailableFil()
    totalNetworkPower = StorageMinerActor.GetTotalStorage()
    numMiners = StorageMarket.GetMinerCount()
    powerCollateral = availableFil * NetworkConstants.POWER_COLLATERAL_PROPORTION * power / totalNetworkPower
    perCapitaCollateral = availableFil * NetworkConstants.PER_CAPITA_COLLATERAL_PROPORTION / numMiners
    collateralRequired = math.Ceil(minerPowerCollateral + minerPerCapitaCollateral)
    return collateralRequired
}</p>

<pre><code>
#### `SubmitPoSt`

**Parameters**

</code></pre>

<p>sh
type SubmitPost struct {
    proofs PoStProof
    doneSet Bitfield
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func SubmitPost(proofs PoStProof, doneSet Bitfield) {
    if msg.From != self.Worker {
        Fatal(&ldquo;not authorized to submit post for miner&rdquo;)
    }</p>

<pre><code>feesRequired := 0
nextProvingPeriodEnd := self.ProvingPeriodEnd + ProvingPeriodDuration(self.SectorSize)

// TODO: rework fault handling, for now anything later than 2 proving periods is invalid
if chain.now() &gt; nextProvingPeriodEnd {
    Fatal(&quot;PoSt submited too late&quot;)
} else if chain.Now() &gt; self.ProvingPeriodEnd {
    feesRequired += ComputeLateFee(self.power, chain.Now() - self.provingPeriodEnd)
}

feesRequired += ComputeTemporarySectorFailureFee(self.sectorSize, self.currentFaultSet)

if msg.Value &lt; feesRequired {
    Fatal(&quot;not enough funds to pay post submission fees&quot;)
}

// we want to ensure that the miner can submit more fees than required, just in case
if msg.Value &gt; feesRequired {
    TransferFunds(msg.From, msg.Value-feesRequired)
}

var seed
if chain.Now() &lt; self.ProvingPeriodEnd {
  // good case, submitted in time
  seed = GetRandFromBlock(self.ProvingPeriodEnd - POST_CHALLENGE_TIME)
} else {
  // bad case, submitted late, need to take new proving period end as reference
  seed = GetRandFromBlock(nextPovingPeriodEnd - POST_CHALLENGE_TIME)
}

faultSet := self.currentFaultSet

if !VerifyPoSt(self.SectorSize, self.provingSet, seed, proof, faultSet) {
    Fatal(&quot;proof invalid&quot;)
}

// The next fault set becomes the current one
self.currentFaultSet = self.nextFaultSet
self.nextFaultSet = EmptySectorSet()

// TODO: penalize for faults

// Remove doneSet from the current sectors
self.Sectors.Subtract(doneSet)

// Update miner power to the amount of data actually proved during the last proving period.
oldPower := self.Power

self.Power = (self.ProvingSet.Size() - faultSet.Count()) * self.SectorSize
StorageMarket.UpdateStorage(self.Power - oldPower)

self.ProvingSet = self.Sectors

// Updating proving period given a fixed schedule, independent of late submissions.
self.ProvingPeriodEnd = nextProvingPeriodEnd

// update next done set
self.NextDoneSet = done
self.ArbitratedDeals.Clear()
</code></pre>

<p>}</p>

<p>func ProvingPeriodDuration(sectorSize uint64) Integer {
    return 24 * 60 * 60 * 2 // number of blocks in one day
}</p>

<p>func ComputeLateFee(power Integer, blocksLate Integer) TokenAmount {
    return 4 // TODO: real collateral calculation, obviously
}</p>

<p>func ComputeTemporarySectorFailureFee(sectorSize BytesAmount, numSectors Integer) TokenAmount {
    return 4 // TODO: something tells me that 4 might not work in all situations. probably should find a better way to compute this
}</p>

<pre><code>
#### `SlashStorageFault`

**Parameters**

</code></pre>

<p>sh
type SlashStorageFault struct {
    miner Address
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func SlashStorageFault() {
    // You can only be slashed once for missing your PoSt.
    if self.SlashedAt &gt; 0 {
        Fatal(&ldquo;miner already slashed&rdquo;)
    }</p>

<pre><code>// Only if the miner is actually late, they can be slashed.
if chain.Now() &lt;= self.ProvingPeriodEnd+GenerationAttackTime(self.SectorSize) {
    Fatal(&quot;miner is not yet tardy&quot;)
}

// Only a miner who is expected to prove, can be slashed.
if self.ProvingSet.Size() == 0 {
    Fatal(&quot;miner is inactive&quot;)
}

// Strip the miner of their power.
StorageMarketActor.UpdateStorage(-1 * self.Power)
self.Power = 0

self.slashedSet = self.ProvingSet
// remove proving set from our sectors
self.sectors.Substract(self.slashedSet)

// clear proving set
self.ProvingSet = nil

self.owedStorageCollateral = StorageMarketActor.StorageCollateralForSize(
    self.slashedSet.Size() * self.SectorSize,
)

self.SlashedAt = CurrentBlockHeight
</code></pre>

<p>}</p>

<pre><code>
#### `GetCurrentProvingSet`

**Parameters**

</code></pre>

<p>sh
type GetCurrentProvingSet struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func GetCurrentProvingSet() [][]byte {
    return self.ProvingSet
}</p>

<pre><code>
&lt;div class=&quot;notices note&quot; &gt;&lt;strong&gt;Note&lt;/strong&gt;: this is unlikely to ever be called on-chain, and will be a very large amount of data. We should reconsider the need for a list of all sector commitments (maybe fixing with accumulators?)&lt;/div&gt;


#### `ArbitrateDeal`

This may be called by anyone to penalize a miner for dropping the data of a deal they committed to before the deal expires. Note: in order to call this, the caller must have the signed deal between the client and the miner in question, this would require out of band communication of this information from the client to acquire.

**Parameters**

</code></pre>

<p>sh
type ArbitrateDeal struct {
    deal Deal
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func AbitrateDeal(deal Deal) {
    if !VM.ValidateSignature(deal, self.Worker) {
        Fatal(&ldquo;invalid signature on deal&rdquo;)
    }</p>

<pre><code>if VM.CurrentBlockHeight() &lt; deal.StartTime {
    Fatal(&quot;Deal not yet started&quot;)
}

if deal.Expiry &lt; VM.CurrentBlockHeight() {
    Fatal(&quot;Deal is expired&quot;)
}

if !self.NextDoneSet.Has(deal.pieceInclusionProof.sectorID) {
    Fatal(&quot;Deal agreement not broken, or arbitration too late&quot;)
}

if self.ArbitratedDeals.Has(deal.commP) {
    Fatal(&quot;cannot slash miner twice for same deal&quot;)
}

if !deal.pieceInclusionProof.Verify(deal.commP, deal.size) {
    Fatal(&quot;invalid piece inclusion proof or size&quot;)
}

storageCollateral := StorageMarketActor.StorageCollateralForSize(deal.size)

if self.owedStorageCollateral &lt; storageCollateral {
    Fatal(&quot;math is hard, and we didnt do it right&quot;)
}

// pay the client the storage collateral
VM.TransferFunds(storageCollateral, deal.client)

// keep track of how much we have payed out
self.owedStorageCollateral -= storageCollateral

// make sure the miner can't be slashed twice for this deal
self.ArbitratedDeals.Add(deal.commP)
</code></pre>

<p>}</p>

<pre><code>
&lt;div class=&quot;notices todo&quot; &gt;&lt;strong&gt;TODO(scaling)&lt;/strong&gt;: This method, as currently designed, must be called once per sector. If a miner agrees to store 1TB (1000 sectors) for a particular client, and loses all that data, the client must then call this method 1000 times, which will be really expensive.&lt;/div&gt;


#### `DePledge`

**Parameters**

</code></pre>

<p>sh
type DePledge struct {
    amount TokenAmount
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func DePledge(amt TokenAmount) {
    if msg.From != self.info.Worker &amp;&amp; msg.From != self.info.owner {
        Fatal(&ldquo;Not authorized to call DePledge&rdquo;)
    }</p>

<pre><code>if self.DePledgeTime &gt; 0 {
    if self.DePledgeTime &gt; VM.CurrentBlockHeight() {
        Fatal(&quot;too early to withdraw collateral&quot;)
    }

    TransferFunds(self.info.owner, self.DePledgedCollateral)
    self.DePledgeTime = 0
    self.DePledgedCollateral = 0
    return
}

collateralRequired = CollateralForPower(self.power)

if amt+collateralRequired &gt; vm.MyBalance() {
    Fatal(&quot;Not enough free collateral to withdraw that much&quot;)
}

self.DePledgedCollateral = amt
self.DePledgeTime = CurrentBlockHeight + DePledgeCooldown
</code></pre>

<p>}</p>

<pre><code>
#### `GetOwner`

**Parameters**
</code></pre>

<p>sh
type GetOwner struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func GetOwner() Address {
    return self.info.owner
}</p>

<pre><code>
#### `GetWorkerAddr`

**Parameters**

</code></pre>

<p>sh
type GetWorkerAddr struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func GetWorkerAddr() Address {
    return self.info.worker
}</p>

<pre><code>
#### `GetPower`

**Parameters**

</code></pre>

<p>sh
type GetPower struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func GetPower() BytesAmount {
    return self.power
}</p>

<pre><code>
#### `GetPeerID`

**Parameters**

</code></pre>

<p>sh
type GetPeerID struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func GetPeerID() PeerID {
    return self.info.peerID
}</p>

<pre><code>
#### `GetSectorSize`

**Parameters**

</code></pre>

<p>sh
type GetSectorSize struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func GetSectorSize() BytesAmount {
    return self.info.sectorSize
}</p>

<pre><code>
#### `UpdatePeerID`

**Parameters**

</code></pre>

<p>sh
type UpdatePeerID struct {
    peerId PeerId
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func UpdatePeerID(pid PeerID) {
    if msg.From != self.info.worker {
        Fatal(&ldquo;only the mine worker may update the peer ID&rdquo;)
    }</p>

<pre><code>self.info.peerID = pid
</code></pre>

<p>}</p>

<pre><code>
#### `ChangeWorker`

Changes the worker address. Note that since Sector Commitments take the miners worker key as an input, any sectors sealed with the old key but not yet submitted to the chain will be invalid. All future sectors must be sealed with the new worker key.

**Parameters**

</code></pre>

<p>sh
type ChangeWorker struct {
    addr Address
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func ChangeWorker(addr Address) {
    if msg.From != self.info.owner {
        Fatal(&ldquo;only the owner can change the worker address&rdquo;)
    }</p>

<pre><code>self.info.worker = addr
</code></pre>

<p>}</p>

<pre><code>
#### `IsLate`

IsLate checks whether the miner has submitted their PoSt on time (i.e. not after ProvingPeriodEnd).

**Parameters**

</code></pre>

<p>sh
type IsLate struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func IsLate() (bool) {
    return self.provingPeriodEnd &lt; VM.CurrentBlockHeight()
}</p>

<pre><code>
#### `IsSlashed`

Checks whether the miner has been slashed and not recovered. Note that if the miner is slashed and recovers, this will return False: it checks current state rather than historical occurence.

**Parameters**

</code></pre>

<p>sh
type IsSlashed struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func IsSlashed() (bool) {
    # SlashedAt is reset on recovery
    return self.SlashedAt &gt; 0
}</p>

<pre><code>
#### `PaymentVerifyInclusion`

Verifies a storage market payment channel voucher's 'Extra' data by validating piece inclusion proof.

**Parameters**

</code></pre>

<p>sh
type PaymentVerify struct {
    Extra Bytes
    Proof Bytes
} representation tuple</p>

<p>type PieceInclusionVoucherData struct {
    CommP Bytes
    PieceSize BigInt
} representation tuple</p>

<p>type InclusionProof struct {
    Sector BigInt // for CommD, also verifies the sector is in sector set
    Proof  Bytes
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func PaymentVerifyInclusion(extra PieceInclusionVoucherData, proof InclusionProof) {
  has, commD := self.GetSector(proof.Sector)
  if !has {
    Fatal(&ldquo;miner does not have required sector&rdquo;)
  }</p>

<p>return ValidatePIP(self.SectorSize, extra.PieceSize, extra.CommP, commD, proof.Proof)
}</p>

<pre><code>

#### `PaymentVerifySector`

Verifies a storage market payment channel voucher's 'Extra' data by checking for presence of a specified sector in miner's sector set.

Miners should prefer payment vouchers with this method used for validation over `PaymentVerifyInclusion`, because posting them to the chain will be much cheaper.

Clients should only create such vouchers after verifying that miners have related sectors in their sector set, and after checking piece inclusion proof.

Miners can incentivize clients to produce such vouchers by applying small 'discount' to amount of token clients have to pay.

**Parameters**

</code></pre>

<p>sh
type PaymentVerify struct {
    Extra Bytes
    Proof Bytes
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func PaymentVerifyInclusion(extra BigInt, proof Bytes) {
  if len(proof) &gt; 0 {
    Fatal(&ldquo;unexpected proof bytes&rdquo;)
  }</p>

<p>return self.HasSector(extra)
}</p>

<pre><code>
#### `AddFaults`

**Parameters**

</code></pre>

<p>sh
type AddFaults struct {
    faults FaultSet
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func AddFaults(faults FaultSet) {
    challengeBlockHeight := self.ProvingPeriodEnd - POST_CHALLENGE_TIME</p>

<pre><code>if VM.CurrentBlockHeight() &lt; challengeBlockHeight {
    // Up to the challenge time new faults can be added.
    self.currentFaultSet = Merge(self.currentFaultSet, faults)
} else {
    // After that they are only accounted for in the next proving period
    self.nextFaultSet = Merge(self.nextFaultSet, faults)
}
</code></pre>

<p>}</p>

<pre><code>
### Payment Channel Actor

- **Code Cid:** `&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;paych&quot;&gt;`

The payment channel actor manages the on-chain state of a point to point payment channel.

</code></pre>

<p>sh
type PaymentChannel struct {
    from Address
    to   Address</p>

<pre><code>toSend       TokenAmount

closingAt      UInt
minCloseHeight UInt

laneStates {UInt:LaneState}
</code></pre>

<p>} representation tuple</p>

<p>type SignedVoucher struct {
  TimeLock BlockHeight
  SecretPreimage Bytes
  Extra ModVerifyParams
  Lane Uint
  Nonce Uint
  Merges []Merge
  Amount TokenAmount
  MinCloseHeight Uint</p>

<p>Signature Signature
}</p>

<p>type ModVerifyParams struct {
  Actor Address
  Method Uint
  Data Bytes
}</p>

<p>type Merge struct {
  Lane Uint
  Nonce Uint
}</p>

<p>type LaneState struct {
  Closed bool
  Redeemed TokenAmount
  Nonce Uint
}</p>

<p>type PaymentChannelMethod union {
  | PaymentChannelConstructor 0
  | UpdateChannelState 1
  | Close 2
  | Collect 3
} representation keyed</p>

<pre><code>
#### Methods

| Name | Method ID |
|--------|-------------|
| `Constructor` | 1 |
| `UpdateChannelState` | 2 |
| `Close` | 3 |
| `Collect` | 4 |

#### `Constructor`

**Parameters**

</code></pre>

<p>sh
type PaymentChannelConstructor struct {
  to Address
}</p>

<pre><code>
**Algorithm**

&lt;div class=&quot;notices todo&quot; &gt;TODO: Define me&lt;/div&gt;


#### `UpdateChannelState`

**Parameters**

</code></pre>

<p>sh
type UpdateChannelState struct {
  sv SignedVoucher
  secret Bytes
  proof Bytes
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func UpdateChannelState(sv SignedVoucher, secret []byte, proof []byte) {
    if !self.validateSignature(sv) {
        Fatal(&ldquo;Signature Invalid&rdquo;)
    }</p>

<pre><code>if chain.Now() &lt; sv.TimeLock {
    Fatal(&quot;cannot use this voucher yet!&quot;)
}

if sv.SecretPreimage != nil {
    if Hash(secret) != sv.SecretPreimage {
        Fatal(&quot;Incorrect secret!&quot;)
    }
}

if sv.Extra != nil {
    ret := vmctx.Send(sv.Extra.Actor, sv.Extra.Method, sv.Extra.Data, proof)
    if ret != 0 {
        Fatal(&quot;spend voucher verification failed&quot;)
    }
}

ls := self.LaneStates[sv.Lane]
if ls.Closed {
    Fatal(&quot;cannot redeem a voucher on a closed lane&quot;)
}

if ls.Nonce &gt; sv.Nonce {
    Fatal(&quot;voucher has an outdated nonce, cannot redeem&quot;)
}

var mergeValue TokenAmount
for _, merge := range sv.Merges {
    if merge.Lane == sv.Lane {
        Fatal(&quot;voucher cannot merge its own lane&quot;)
    }

    ols := self.LaneStates[merge.Lane]
    if ols.Nonce &gt;= merge.Nonce {
        Fatal(&quot;merge in voucher has outdated nonce, cannot redeem&quot;)
    }

    mergeValue += ols.Redeemed
    ols.Nonce = merge.Nonce
}

ls.Nonce = sv.Nonce
balanceDelta = sv.Amount - (mergeValue + ls.Redeemed)
ls.Redeemed = sv.Amount

newSendBalance = self.ToSend + balanceDelta
if newSendBalance &lt; 0 {
    // TODO: is this impossible?
    Fatal(&quot;voucher would leave channel balance negative&quot;)
}

if newSendBalance &gt; self.Balance {
    Fatal(&quot;not enough funds in channel to cover voucher&quot;)
}

self.ToSend = newSendBalance

if sv.MinCloseHeight != 0 {
    if self.ClosingAt != 0 &amp;&amp; self.ClosingAt &lt; sv.MinCloseHeight {
        self.ClosingAt = sv.MinCloseHeight
    }
    if self.MinCloseHeight &lt; sv.MinCloseHeight {
        self.MinCloseHeight = sv.MinCloseHeight
    }
}
</code></pre>

<p>}</p>

<p>func Hash(b []byte) []byte {
    return blake2b.Sum(b)
}</p>

<pre><code>
#### `Close`

**Parameters**

</code></pre>

<p>sh
type Close struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
const ChannelClosingDelay = 6 * 60 * 2 // six hours</p>

<p>func Close() {
    if msg.From != self.From &amp;&amp; msg.From != self.To {
        Fatal(&ldquo;not authorized to close channel&rdquo;)
    }
    if self.ClosingAt != 0 {
        Fatal(&ldquo;Channel already closing&rdquo;)
    }</p>

<pre><code>self.ClosingAt = chain.Now() + ChannelClosingDelay
if self.ClosingAt &lt; self.MinCloseHeight {
    self.ClosingAt = self.MinCloseHeight
}
</code></pre>

<p>}</p>

<pre><code>
#### `Collect`

**Parameters**

</code></pre>

<p>sh
type Collect struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func Collect() {
    if self.ClosingAt == 0 {
        Fatal(&ldquo;payment channel not closing or closed&rdquo;)
    }</p>

<pre><code>if chain.Now() &lt; self.ClosingAt {
    Fatal(&quot;Payment channel not yet closed&quot;)
}

TransferFunds(self.From, self.Balance-self.ToSend)
TransferFunds(self.To, self.ToSend)
</code></pre>

<p>self.ToSend = 0
}</p>

<pre><code>
### Multisig Account Actor

- **Code Cid**: `&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;multisig&quot;&gt;`

A basic multisig account actor. Allows sending of messages like a normal account actor, but with the requirement of M of N parties agreeing to the operation. Completed and/or cancelled operations stick around in the actors state until explicitly cleared out. Proposers may cancel transactions they propose, or transactions by proposers who are no longer approved signers.

Self modification methods (add/remove signer, change requirement) are called by
doing a multisig transaction invoking the desired method on the contract itself. This means the 'signature
threshold' logic only needs to be implemented once, in one place.

The [init actor](#init-actor) is used to create new instances of the multisig.

</code></pre>

<p>sh
type MultisigActorState struct {
    signers [Address]
    required UInt
    nextTxId UInt
    initialBalance UInt
    startingBlock UInt
    unlockDuration UInt
    transactions {UInt:Transaction}
}</p>

<p>type Transaction struct {
    txID UInt
    to Address
    value TokenAmount
    method &amp;ActorMethod
    approved [Address]
    completed Bool
    canceled Bool
    retcode UInt
}</p>

<pre><code>
#### Methods

| Name | Method ID |
|--------|-------------|
| `MultisigConstructor` | 1 |
| `Propose` | 2 |
| `Approve` | 3 |
| `Cancel` | 4 |
| `ClearCompleted` | 5 |
| `AddSigner` | 6 |
| `RemoveSigner` | 7 |
| `SwapSigner` | 8 |
| `ChangeRequirement` | 9 |


#### `Constructor`

This method sets up the initial state for the multisig account

**Parameters**

</code></pre>

<p>sh
type MultisigConstructor struct {
    ## The addresses that will be the signatories of this wallet.
    signers [Address]
    ## The number of signatories required to perform a transaction.
    required UInt
    ## Unlock time (in blocks) of initial filecoin balance of this wallet. Unlocking is linear.
    unlockDuration UInt
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func Multisig(signers []Address, required UInt, unlockDuration UInt) {
    self.Signers = signers
    self.Required = required
    self.initialBalance = msg.Value
    self.unlockDuration = unlockDuration
    self.startingBlock = VM.CurrentBlockHeight()
}</p>

<pre><code>
#### `Propose`

Propose is used to propose a new transaction to be sent by this multisig. The proposer must be a signer, and the proposal also serves as implicit approval from the proposer. If only a single signature is required, then the transaction is executed immediately.

**Parameters**


</code></pre>

<p>sh
type Propose struct {
    ## The address of the target of the proposed transaction.
    to Address
    ## The amount of funds to send with the proposed transaction.
    value TokenAmount
    ## The method and parameters that will be invoked on the proposed transactions target.
    method &amp;ActorMethod
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func Propose(to Address, value TokenAmount, method String, params Bytes) UInt {
    if !isSigner(msg.From) {
        Fatal(&ldquo;not authorized&rdquo;)
    }</p>

<pre><code>txid := self.NextTxID
self.NextTxID++

tx := Transaction{
    TxID:     txid,
    To:       to,
    Value:    value,
    Method:   method,
    Params:   params,
    Approved: []Address{msg.From},
}

self.Transactions.Append(tx)

if self.Required == 1 {
    if !self.canSpend(tx.value) {
        Fatal(&quot;transaction amount exceeds available&quot;)
    }
    tx.RetCode = vm.Send(tx.To, tx.Value, tx.Method, tx.Params)
    tx.Complete = true
}

return txid
</code></pre>

<p>}</p>

<pre><code>
#### `Approve`

Approve is called by a signer to approve a given transaction. If their approval pushes the approvals for this transaction over the threshold, the transaction is executed.

**Parameters**

</code></pre>

<p>sh
type Approve struct {
    ## The ID of the transaction to approve.
    txid UInt
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func Approve(txid UInt) {
    if !self.isSigner(msg.From) {
        Fatal(&ldquo;not authorized&rdquo;)
    }</p>

<pre><code>tx := self.getTransaction(txid)
if tx.Complete {
    Fatal(&quot;transaction already completed&quot;)
}
if tx.Canceled {
    Fatal(&quot;transaction canceled&quot;)
}

for _, signer := range tx.Approved {
    if signer == msg.From {
        Fatal(&quot;already signed this message&quot;)
    }
}

tx.Approved.Append(msg.From)

if len(tx.Approved) &gt;= self.Required {
    if !self.canSpend(tx.Value) {
        Fatal(&quot;transaction amount exceeds available&quot;)
    }
    tx.RetCode = vm.Send(tx.To, tx.Value, tx.Method, tx.Params)
    tx.Complete = true
}
</code></pre>

<p>}</p>

<pre><code>
#### `Cancel`

**Parameters**

</code></pre>

<p>sh
type Cancel struct {
    txid UInt
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func Cancel(txid UInt) {
    if !self.isSigner(msg.From) {
        Fatal(&ldquo;not authorized&rdquo;)
    }</p>

<pre><code>tx := self.getTransaction(txid)
if tx.Complete {
    Fatal(&quot;cannot cancel completed transaction&quot;)
}
if tx.Canceled {
    Fatal(&quot;transaction already canceled&quot;)
}

proposer := tx.Approved[0]
if proposer != msg.From &amp;&amp; isSigner(proposer) {
    Fatal(&quot;cannot cancel another signers transaction&quot;)
}

tx.Canceled = true
</code></pre>

<p>}</p>

<pre><code>
#### `ClearCompleted`

**Parameters**

</code></pre>

<p>sh
type ClearCompleted struct {
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func ClearCompleted() {
    if !self.isSigner(msg.From) {
        Fatal(&ldquo;not authorized&rdquo;)
    }</p>

<pre><code>for tx := range self.Transactions {
    if tx.Completed || tx.Canceled {
        self.Transactions.Remove(tx)
    }
}
</code></pre>

<p>}</p>

<pre><code>
#### `AddSigner`

**Parameters**

</code></pre>

<p>sh
type AddSigner struct {
    signer Address
    increaseReq bool
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func AddSigner(signer Address, increaseReq bool) {
    if msg.From != self.Address {
        Fatal(&ldquo;add signer must be called by wallet itself&rdquo;)
    }
    if self.isSigner(signer) {
        Fatal(&ldquo;new address is already a signer&rdquo;)
    }
    if increaseReq {
        self.Required = self.Required + 1
    }</p>

<pre><code>self.Signers.Append(signer)
</code></pre>

<p>}</p>

<pre><code>
#### `RemoveSigner`

**Parameters**

</code></pre>

<p>sh
type RemoveSigner struct {
    signer Address
    decreaseReq bool
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func RemoveSigner(signer Address, decreaseReq bool) {
    if msg.From != self.Address {
        Fatal(&ldquo;remove signer must be called by wallet itself&rdquo;)
    }
    if !self.isSigner(signer) {
        Fatal(&ldquo;given address was not a signer&rdquo;)
    }
    if decreaseReq || len(self.Signers)-1 &lt; self.Required {
        // Reduce Required outherwise the wallet is locked out
        self.Required = self.Required - 1
    }</p>

<pre><code>self.Signers.Remove(signer)
</code></pre>

<p>}</p>

<pre><code>
#### `SwapSigner`

**Parameters**

</code></pre>

<p>sh
type SwapSigner struct {
    old Address
    new Address
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func SwapSigner(old Address, new Address) {
    if msg.From != self.Address {
        Fatal(&ldquo;swap signer must be called by wallet itself&rdquo;)
    }
    if !self.isSigner(old) {
        Fatal(&ldquo;given old address was not a signer&rdquo;)
    }
    if self.isSigner(new) {
        Fatal(&ldquo;given new address was already a signer&rdquo;)
    }</p>

<pre><code>self.Signers.Remove(old)
self.Signers.Append(new)
</code></pre>

<p>}</p>

<pre><code>
#### `ChangeRequirement`

**Parameters**

</code></pre>

<p>sh
type ChangeRequirement struct {
    requirement UInt
} representation tuple</p>

<pre><code>
**Algorithm**

</code></pre>

<p>go
func ChangeRequirement(req UInt) {
    if msg.From != self.Address {
        Fatal(&ldquo;change requirement must be called by wallet itself&rdquo;)
    }
    if req &lt; 1 {
        Fatal(&ldquo;requirement must be at least 1&rdquo;)
    }
    if req &gt; len(self.Signers) {
        Fatal(&ldquo;requirement must be less than number of signers&rdquo;)
    }</p>

<pre><code>self.Required = req
</code></pre>

<p>}</p>

<pre><code>
## Helper Methods

The various helper methods called above are defined here.

</code></pre>

<p>go
func isSigner(a Address) bool {
    for signer := range self.Signers {
        if a == signer {
            return true
        }
    }
    return false
}</p>

<pre><code>
</code></pre>

<p>go
func getTransaction(txid UInt) Transaction {
    tx, ok := self.Transactions[txid]
    if !ok {
        Fatal(&ldquo;no such transaction&rdquo;)
    }</p>

<pre><code>return tx
</code></pre>

<p>}</p>

<pre><code>
</code></pre>

<p>go
func AggregateBitfields(faults []FaultSet) Bitfield {
    var out Bitfield
    for _, f := range faults {
        out = out.Union(f.bitField)
    }
    return out
}</p>

<pre><code>
</code></pre>

<p>go
func BurnFunds(amt TokenAmount) {
    TransferFunds(BurntFundsAddress, amt)
}</p>

<pre><code>
</code></pre>

<p>go
func canSpend(amt TokenAmount) bool {
    if self.unlockDuration == 0 {
        return true
    }
    var MinAllowableBalance = (self.initialBalance / self.unlockDuration) * (VM.CurrentBlockHeight() - self.startingBlock)
    return MinAllowableBalance &gt;= (vm.MyBalance() - amt)
}
```</p>

</article>

      
<div class="align-center book-git-footer justify-end">
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/actors.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#filecoin-state-machine-actors">Filecoin State Machine Actors</a>
<ul>
<li><a href="#actor-state">Actor State</a></li>
<li><a href="#system-actors">System Actors</a></li>
<li><a href="#built-in-actors">Built In Actors</a>
<ul>
<li><a href="#init-actor">Init Actor</a>
<ul>
<li><a href="#methods">Methods</a></li>
<li><a href="#constructor"><code>Constructor</code></a></li>
<li><a href="#exec"><code>Exec</code></a></li>
<li><a href="#getidforaddress"><code>GetIdForAddress</code></a></li>
</ul></li>
<li><a href="#account-actor">Account Actor</a>
<ul>
<li><a href="#methods-1">Methods</a></li>
<li><a href="#getaddress"><code>GetAddress</code></a></li>
</ul></li>
<li><a href="#storage-market-actor">Storage Market Actor</a>
<ul>
<li><a href="#methods-2">Methods</a></li>
<li><a href="#constructor-1"><code>Constructor</code></a></li>
<li><a href="#createstorageminer"><code>CreateStorageMiner</code></a></li>
<li><a href="#slashconsensusfault"><code>SlashConsensusFault</code></a></li>
<li><a href="#updatestorage"><code>UpdateStorage</code></a></li>
<li><a href="#gettotalstorage"><code>GetTotalStorage</code></a></li>
<li><a href="#powerlookup"><code>PowerLookup</code></a></li>
<li><a href="#isminer"><code>IsMiner</code></a></li>
<li><a href="#storagecollateralforsize"><code>StorageCollateralForSize</code></a></li>
</ul></li>
</ul></li>
<li><a href="#storage-miner-actor">Storage Miner Actor</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
