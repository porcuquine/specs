<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Mining
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->


  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fmining\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><a href="../../docs/proofs/"><strong>Proofs</strong></a></p>

<ul>
<li><a href="../../docs/zigzag-porep/">Proof-of-Replication</a>

<ul>
<li><a href="../../docs/zigzag-commitments/">ZigZag Commitments</a></li>
<li><a href="../../docs/zigzag-circuit/">Circuit</a></li>
</ul></li>
<li><a href="../../docs/proof-of-spacetime/">Proof-of-Spacetime</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Mining
  
</strong>
</header>

      
<article class="markdown">
  

<h3 id="what-is-the-filecoin-mining-process">What is the Filecoin Mining Process</h3>

<p>An active participant in the filecoin consensus process is a storage miner and expected consensus block proposer. They are responsible for storing data for the filecoin network and also for driving the filecoin consensus process. Miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning <code>ticket</code> to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.</p>

<p>Any block proposer must be a storage miner, but storage miners can avoid performing the block proposer tasks, however in this way, they will be losing out on block rewards and transaction fees.</p>

<h2 id="the-miner-actor">The Miner Actor</h2>

<p>After successfully calling <code>CreateStorageMiner</code>, a miner actor will be created on-chain, and registered in the storage market. This miner, like all other Filecoin State Machine actors, has a fixed set of methods that can be used to interact with or control it.</p>

<p>For details on the methods on the miner actor, see its entry in the <a href="../actors#storage-miner-actor">actors spec</a>.</p>

<h3 id="owner-worker-distinction">Owner Worker distinction</h3>

<p>The miner actor has two distinct &lsquo;controller&rsquo; addresses. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a &lsquo;hot wallet&rsquo; key.</p>

<h3 id="storage-mining-cycle">Storage Mining Cycle</h3>

<p>Storage miners must continually produce Proofs of SpaceTime over their storage to convince the network that they are actually storing the sectors that they have committed to. Each PoSt covers a miner&rsquo;s entire storage.</p>

<h4 id="step-0-registration">Step 0: Registration</h4>

<p>To initially become a miner, a miner first register a new miner actor on-chain. This is done through the storage market actor&rsquo;s <a href="../actors#createstorageminer"><code>CreateStorageMiner</code></a> method. The call will then create a new miner actor instance and return its address.</p>

<p>The next step is to place one or more storage market asks on the market. This is done through the storage markets <a href="../actors#addask"><code>AddAsk</code></a> method. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p>

<p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the section on <a href="../storage-market#deal">deal</a>.</p>

<p>When they have a full sector, they should seal it. This is done by invoking <a href="../proofs#seal"><code>PoRep.Seal</code></a> on the sector.</p>

<h4 id="step-1-commit">Step 1: Commit</h4>

<p>When the miner has completed their first seal, they should post it on-chain using <a href="../actors#commitsector">CommitSector</a>. If the miner had zero committed sectors prior to this call, this begins their proving period.</p>

<p>The proving period is a fixed amount of time in which the miner must submit a Proof of Space Time to the network.</p>

<p>During this period, the miner may also commit to new sectors, but they will not be included in proofs of space time until the next proving period starts.
For example, if a miner currently PoSts for 10 sectors, and commits to 20 more sectors. The next PoSt they submit (i.e. the one they&rsquo;re currently proving) will be for 10 sectors again, the subsequent one will be for 30.</p>

<p>TODO: sectors need to be globally unique. This can be done either by having the seal proof prove the sector is unique to this miner in some way, or by having a giant global map on-chain is checked against on each submission. As the system moves towards sector aggregation, the latter option will become unworkable, so more thought needs to go into how that proof statement could work.</p>

<h4 id="step-2-proving-storage-post-creation">Step 2: Proving Storage (PoSt creation)</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ProveStorage</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">commR</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="nx">challengeBlockHeight</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span>

    <span class="c1">// Faults to be used are the currentFaultSet for the miner.
</span><span class="c1"></span>    <span class="nx">faults</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">currentFaultSet</span>
    <span class="nx">seed</span> <span class="o">:=</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">challengeBlockHeight</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sectors</span><span class="p">,</span> <span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Note: See <a href="../proof-of-spacetime">&lsquo;Proof of Space Time&rsquo;</a> for more details.</p>

<p>The proving set remains consistent during the proving period. Any sectors added in the meantime will be included in the next proving set, at the beginning of the next proving period.</p>

<h4 id="step-3-post-submission">Step 3: PoSt Submission</h4>

<p>When the miner has completed their PoSt, they must submit it to the network by calling <a href="../actors#submitpost">SubmitPoSt</a>. There are two different times that this <em>could</em> be done.</p>

<ol>
<li><strong>Standard Submission</strong>: A standard submission is one that makes it on-chain before the end of the proving period. The length of time it takes to compute the PoSts is set such that there is a grace period between then and the actual end of the proving period, so that the effects of network congestion on typical miner actions is minimized.</li>
<li><strong>Penalized Submission</strong>: A penalized submission is one that makes it on-chain after the end of the proving period, but before the generation attack threshold. These submissions count as valid PoSt submissions, but the miner must pay a penalty for their late submission. (See &lsquo;<a href="../faults">Faults</a>&rsquo; for more information)

<ul>
<li>Note: In this case, the next PoSt should still be started at the beginning of the proving period, even if the current one is not yet complete. Miners must submit one PoSt per proving period.</li>
</ul></li>
</ol>

<p>Along with the PoSt submission, miners may also submit a set of sectors that they wish to remove from their proving set. This is done by selecting the sectors in the &lsquo;done&rsquo; bitfield passed to <code>SubmitPoSt</code>.</p>

<h3 id="stop-mining">Stop Mining</h3>

<p>In order to stop mining, a miner must complete all of its storage contracts, and remove them from their proving set during a PoSt submission. A miner may then call <a href="../actors#depledge"><code>DePledge()</code></a> to retrieve their collateral. <code>DePledge</code> must be called twice, once to start the cooldown, and once again after the cooldown to reclaim the funds. The cooldown period is to allow clients whose files have been dropped by a miner to slash them before they get their money back and get away with it.</p>

<h3 id="faults">Faults</h3>

<p>Faults are described in the <a href="../faults">faults document</a>.</p>

<h3 id="on-being-slashed-wip-needs-discussion">On Being Slashed (WIP, needs discussion)</h3>

<p>If a miner is slashed for failing to submit their PoSt on time, they currently lose all their pledge collateral. They do not necessarily lose their storage collateral. Storage collateral is lost when a miner&rsquo;s clients slash them for no longer having the data. Missing a PoSt does not necessarily imply that a miner no longer has the data. There should be an additional timeout here where the miner can submit a PoSt, along with &lsquo;refilling&rsquo; their pledge collateral. If a miner does this, they can continue mining, their mining power will be reinstated, and clients can be assured that their data is still there.</p>

<p>TODO: disambiguate the two collaterals across the entire spec</p>

<p>Review Discussion Note: Taking all of a miners collateral for going over the deadline for PoSt submission is really really painful, and is likely to dissuade people from even mining filecoin in the first place (If my internet going out could cause me to lose a very large amount of money, that leads to some pretty hard decisions around profitability). One potential strategy could be to only penalize miners for the amount of sectors they could have generated in that timeframe.</p>

<h2 id="mining-blocks">Mining Blocks</h2>

<p>Having registered as a miner, it&rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest <a href="../expected-consensus#tipsets">TipSets</a> seen on the network.</p>

<p>For additional details around how consensus works in Filecoin, see the <a href="../expected-consensus">expected consensus spec</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how &ldquo;Tickets&rdquo; should be validated during block validation.</p>

<h3 id="receiving-blocks">Receiving Blocks</h3>

<p>When receiving blocks from the network (via <a href="../data-propagation">block propagation</a>), a miner must do the following:</p>

<ol>
<li>Check their validity (see <a href="#block-validation">below</a>).</li>
<li>Assemble a TipSet with all valid blocks with common parents and the same number of tickets in their <code>Tickets</code> array.</li>
</ol>

<p>A miner may sometimes receive blocks belonging to different TipSets (i.e. whose parents are not the same). In that case, they must choose which TipSet to mine on.</p>

<p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier TipSet rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="../expected-consensus#chain-selection">chain selection</a> in the Expected Consensus spec.</p>

<h3 id="block-validation">Block Validation</h3>

<p>The block structure and serialization is detailed in <a href="../data-structures#block">the datastructures spec - block</a>. Check there for details on fields and types.</p>

<p>In order to validate a block coming in from the network at height <code>N</code> was well mined a miner must do the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">VerifyBlock</span><span class="p">(</span><span class="nx">blk</span> <span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 1. Verify Signature
</span><span class="c1"></span>    <span class="nx">pubk</span> <span class="o">:=</span> <span class="nf">GetPublicKey</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Miner</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">BlockSig</span><span class="p">,</span> <span class="nx">pubk</span><span class="p">,</span> <span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid block signature&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 2. Verify Timestamp
</span><span class="c1"></span>    <span class="c1">// first check that it is not in the future
</span><span class="c1"></span>    <span class="c1">// allowing for some small grace period to deal with small asynchrony
</span><span class="c1"></span>    <span class="c1">// a potential default for ALLOWABLE_CLOCK_DRIFT could be 2/3*blockTime
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">GetTime</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nf">networkTime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">ALLOWABLE_CLOCK_DRIFT</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;block was generated too far in the future&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// next check that it is appropriately delayed from its parents including
</span><span class="c1"></span>    <span class="c1">// null blocks.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">GetTime</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">minParentTime</span><span class="p">()</span><span class="o">+</span><span class="p">(</span><span class="nx">BLOCK_DELAY</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Tickets</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;block was generated too soon&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3. Verify ParentWeight
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nx">ParentWeight</span> <span class="o">!=</span> <span class="nf">ComputeWeight</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Parents</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid parent weight&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 4. Verify Tickets
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">VerifyTickets</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;tickets were invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 5. Verify ElectionProof
</span><span class="c1"></span>    <span class="c1">// Note that this step must explicitly check that the
</span><span class="c1"></span>    <span class="c1">// miner has not been slashed or is not late to submitting a PoSt
</span><span class="c1"></span>    <span class="c1">// i.e. that this is still a valid miner
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">VerifyElectionProof</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;election was invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 6. Verify Message Signatures
</span><span class="c1"></span>    <span class="nx">state</span> <span class="o">:=</span> <span class="nf">GetParentState</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Parents</span><span class="p">)</span>
    <span class="nx">blsMessages</span> <span class="o">:=</span> <span class="nf">LoadMessages</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Messages</span><span class="p">.</span><span class="nx">blsMsgs</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">blsPubKeys</span> <span class="p">[]</span><span class="nx">PublicKey</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blsMessages</span> <span class="p">{</span>
          <span class="nx">blsPubKeys</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nf">LookupPublicKey</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateBLSSignature</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">BLSAggregate</span><span class="p">,</span> <span class="nx">blsMessages</span><span class="p">,</span> <span class="nx">blsPubKeys</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;aggregated bls signature failed to validate&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">secpkMessages</span> <span class="o">:=</span> <span class="nf">LoadMessages</span><span class="p">(</span><span class="nx">bls</span><span class="p">.</span><span class="nx">Messages</span><span class="p">.</span><span class="nx">secpkMessages</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">secpkMessages</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;secpk message %d had invalid signature&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 7. Validate State Transitions
</span><span class="c1"></span>    <span class="nx">receipts</span> <span class="o">:=</span> <span class="nf">LoadReceipts</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">MessageReceipts</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blsMessages</span> <span class="p">{</span>
        <span class="nx">receipt</span> <span class="o">:=</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">receipt</span> <span class="o">!=</span> <span class="nx">receipts</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;message receipt mismatch&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">secpkMessages</span> <span class="p">{</span>
      <span class="nx">receipt</span> <span class="o">:=</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">receipt</span> <span class="o">!=</span> <span class="nx">receipts</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blsMessages</span><span class="p">)]</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;message receipt mismatch&#34;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nf">Cid</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">blk</span><span class="p">.</span><span class="nx">StateRoot</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;state roots mismatch&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">state</span> <span class="nx">StateTree</span><span class="p">)</span> <span class="nf">LookupPublicKey</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">PubKey</span> <span class="p">{</span>
    <span class="nx">act</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">act</span><span class="p">.</span><span class="nx">Code</span> <span class="o">==</span> <span class="nx">AccountActor</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only account actors have public keys&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">ast</span> <span class="o">:=</span> <span class="nf">LoadAccountActorState</span><span class="p">(</span><span class="nx">act</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">act</span><span class="p">.</span><span class="nx">Address</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">BLS</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">ExtractBLSPubKey</span><span class="p">(</span><span class="nx">act</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;can only look up public keys for BLS controlled accounts&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Get the canonical randomness from a block.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">ticket</span> <span class="o">:=</span> <span class="nf">minTicket</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">ticket</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>If all of this lines up, the block is valid. The miner repeats this for all blocks in a TipSet, and for all TipSets formed from incoming blocks.</p>

<p>Once they&rsquo;ve ensured all blocks in the heaviest TipSet received were properly mined, they can mine on top of it. If they weren&rsquo;t, the miner may need to ensure the next heaviest <code>Tipset</code> was properly mined. This might mean the same <code>Tipset</code> with invalid blocks removed, or an altogether different one.</p>

<p>If no valid blocks are received, a miner may run leader election again (see <a href="../expected-consensus#ticket-generation">ticket generation</a>).</p>

<h3 id="ticket-validation">Ticket Validation</h3>

<p>For ticket generation, see <a href="../expected-consensus#ticket-generation">ticket generation</a>.</p>

<p>A ticket can be verified to have been generated in the appropriate number of rounds by looking at the <code>Tickets</code> array, and ensuring that each subsequent ticket (leading to the final ticket in that array) was generated using the previous one in the array (or in the prior block if the array is empty). Note that this has implications on block size, and client memory requirements, though on expectation, the <code>Tickets</code> array should only contain one Ticket. Put another way, each Ticket should be generated from the prior one in the ticket-chain.</p>

<p>Succinctly, the process of verifying a block&rsquo;s tickets is as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: received block, storage market actor S, miner&#39;s public key PK, a public VDF validation key vk
Output: 0, 1

0. Get the tickets
    i. tickets &lt;-- block.tickets
For each ticket, idx: tickets
1. Verify its VRF Proof
    i. # get the appropriate parent
        if idx == 0:
            # the first was derived from the prior block&#39;s last ticket
            parent = parentBlock.lastTicket
        else:
            parent = tickets[idx - 1]
    ii. # generate the VRFInput
        input &lt;-- VRFPersonalization.Ticket | parent.VDFOutput
    iii. # verify the VRF
        VRFState &lt;-- ECVRF_Verify(PK, ticket.VRFProof, input)
        if VRFState == &#34;INVALID&#34;:
            return 0
2. Verify its VDF Proof
    i. # generate the VDF input
        VRFOutput &lt;-- ECVRF_proof_to_hash(ticket.VRFProof)
    ii. # verify
        VDFState &lt;-- VDF_verify(vk, VRFOutput, ticket.VDFOutput, ticket.VDFProof)
        if VDFState == &#34;NO&#34;:
            return 0
3. Return results
    return 1</code></pre></div>
<p>Notice that there is an implicit check that all tickets in the <code>Tickets</code> array are signed by the same miner.</p>

<h3 id="election-validation">Election Validation</h3>

<p>For election proof generation, see <a href="../expected-consensus#checking-election-results">checking election results</a>.</p>

<p>In order to determine that the mined block was generated by an elegible miner, one must check its <code>ElectionProof</code>.</p>

<p>Succinctly, the process of verifying a block&rsquo;s election proof at round N, is as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: received block, storage market actor S, miner&#39;s public key PK, a public parameter K
Output: 0, 1

0. Get the election proof, total power, miner power
        i. electionProof &lt;-- block.electionProof
        ii. # get total market power
            S &lt;-- storageMarket(N)
            p_n &lt;-- S.GetTotalStorage()
        iii. # get miner power
            p_m &lt;-- GetMinersPowerAt(N, PK)
1. Ensure the miner was not slashed or late: in that case, their power would be 0 and can just abort.
        i. # Check for a reported fault or late submission
            if p_m == 0
                return 0
2. Determine the miner&#39;s power fraction
        i. # Get power fraction
              p_f &lt;-- p_m/p_n
3. Ensure that the scratched ticket is a winner
        i. # get the deterministic output from the election proof
            VRFOutput &lt;-- ECVRF_proof_to_hash(electionProof.VRFProof)
        ii. # map p_f onto [0, 2^HashLen]
            normalized_power &lt;-- p_f * 2^HashLen
          iii. # Compare the miner&#39;s scratchValue to the miner&#39;s normalized power fraction
              if readLittleEndian(VRFOutput) &gt; normalized_power:
                return 0
4. Get the appropriate ticket from the ticket chain
        i. # Get the tipset K rounds back
            appropriateTipset &lt;-- lookback(K)
        ii. # Take its min ticket (already validated)
            scratchedTicket &lt;-- appropriateTipset.minTicket()
5. Verify Election Proof validity
        i. # generate the VRFInput from the scratched ticket
            input &lt;-- VRFPersonalization.ElectionProof | scratchedTicket.VDFOutput
        ii. # Check that the election proof was correctly generated by the miner
            # using the appropriate ticket
            VRFState &lt;-- ECVRF_Verify(miner.PK, electionProof.VRFProof, input)
            if VRFState == &#34;INVALID&#34;:
                return 0
5. Everything checks out, it&#39;s a valid election proof
        return 1</code></pre></div>
<h3 id="ticket-generation">Ticket Generation</h3>

<p>For details of ticket generation, see the <a href="../expected-consensus#ticket-generation">expected consensus spec</a>.</p>

<p>New tickets are generated using the last ticket in the ticket-chain. Generating a new ticket will take some amount of time (as imposed by the VDF in Expected Consensus).</p>

<p>Because of this, on expectation, as it is produced, the miner will hear about other blocks being mined on the network. By the time they have generated their new ticket, they can check whether they themselves are eligible to mine a new block (see <a href="#block-creation">block creation</a>).</p>

<p>At any height <code>H</code>, there are three possible situations:
- The miner is eligible to mine a block: they produce their block and form a TipSet with it and other blocks received in this round (if there are any), and resume mining at the next height <code>H+1</code>.
- The miner is not eligible to mine a block but has received blocks: they form a TipSet with them and resume mining at the next height <code>H+1</code>.
- The miner is not eligible to mine a block and has received no blocks: they run leader election again, using:
    - their losing ticket from the last leader election to produce a new ticket (the <code>Tickets</code> array in the block to be published grows with each new ticket generated).
    - the ticket <code>H + 1 - K</code> blocks back to attempt to generate an <code>ElectionProof</code>.</p>

<p>This process is repeated until either a winning ticket is found (and block published) or a new valid TipSet comes in from the network.</p>

<p>Let&rsquo;s illustrate this with an example.</p>

<p>Miner M is mining at Height H.
Heaviest tipset at H-1 is {B0}
- New Round:
    - M produces a ticket at H, from B0&rsquo;s ticket (the min ticket at H-1)
    - M draws the ticket from height H-K to generate an ElectionProof
    - That ElectionProof is invalid
    - M has not heard about other blocks on the network.
- New Round:
    - M produces a ticket at H + 1 using the ticket produced at H last round.
    - M draws a ticket from height H+1-K to generate an ElectionProof
    - That ElectionProof is valid
    - M generates a block B1
    - M has received blocks B2, B3 from the network with the same parents and same height.
    - M forms a tipset {B1, B2, B3}
- Finding the new min ticket/extending the ticket chain:
    - M compares the final tickets in {B1,B2,B3} (each has two tickets in their <code>Tickets</code> array). B2 has the smallest final ticket. B2 should be used to extend the ticket chain, conceptually.
- New Round:
    - M produces a new ticket at H + 2 using B2&rsquo;s final ticket (the min final ticket in {B1, B2, B3})
    - M draws a ticket from H+2-K to generate an ElectionProof
    - That ElectionProof is invalid
    - M has received B4 from the network, mined atop {B1,B2,B3}
- New Round with M mining atop B4</p>

<p>Anytime a miner receives new blocks, it should evaluate which is the heaviest TipSet it knows about and mine atop it.</p>

<h3 id="block-creation">Block Creation</h3>

<p>Scratching a winning ticket, and armed with a valid <code>ElectionProof</code>, a miner can now publish a new block!</p>

<p>To create a block, the eligible miner must compute a few fields:</p>

<ul>
<li><code>Tickets</code> - An array containing a new ticket, and, if applicable, any intermediary tickets generated to prove appropriate delay for any failed election attempts. See <a href="../expected-consensus#ticket-generation">ticket generation</a>.</li>
<li><code>ElectionProof</code> - A signature over the final ticket from the <code>Tickets</code> array proving. See <a href="../expected-consensus#checking-election-results">checking election results</a>.</li>
<li><code>ParentWeight</code> - As described in <a href="../expected-consensus#chain-weighting">Chain Weighting</a>.</li>
<li><code>Parents</code> - the CIDs of the parent blocks.</li>
<li><code>ParentState</code> - Note that it will not end up in the newly generated block, but is necessary to compute to generate other fields. To compute this:

<ul>
<li>Take the <code>ParentState</code> of one of the blocks in the chosen parent set (invariant: this is the same value for all blocks in a given parent set).</li>
<li>For each block in the parent set, ordered by their tickets:</li>
<li>Apply each message in the block to the parent state, in order. If a message was already applied in a previous block, skip it.</li>
<li>Transaction fees are given to the miner of the block that the first occurance of the message is included in. If there are two blocks in the parent set, and they both contain the exact same set of messages, the second one will receive no fees.</li>
<li>It is valid for messages in two different blocks of the parent set to conflict, that is, A conflicting message from the combined set of messages will always error.  Regardless of conflicts all messages are applied to the state.</li>
<li>TODO: define message conflicts in the state-machine doc, and link to it from here</li>
</ul></li>
<li><code>MsgRoot</code> - To compute this:

<ul>
<li>Select a set of messages from the mempool to include in the block.</li>
<li>Separate the messages into BLS signed messages and secpk signed messages</li>
<li>For the BLS messages:</li>
<li>Strip the signatures off of the messages, and insert all the bare <code>Message</code>s for them into a sharray.</li>
<li>Aggregate all of the bls signatures into a single signature and use this to fill out the <code>BLSAggregate</code> field</li>
<li>For the secpk messages:</li>
<li>Insert each of the secpk <code>SignedMessage</code>s into a sharray</li>
<li>Create a <code>TxMeta</code> object and fill each of its fields as follows:</li>
<li><code>blsMessages</code>: the root cid of the bls messages sharray</li>
<li><code>secpkMessages</code>: the root cid of the secp messages sharray</li>
<li>The cid of this <code>TxMeta</code> object should be used to fill the <code>MsgRoot</code> field of the block header.</li>
</ul></li>
<li><code>BLSAggregate</code> - The aggregated signatures of all messages in the block that used BLS signing.</li>
<li><code>StateRoot</code> - Apply each chosen message to the <code>ParentState</code> to get this.

<ul>
<li>Note: first apply bls messages in the order that they appear in the blsMsgs sharray, then apply secpk messages in the order that they appear in the secpkMessages sharray.</li>
</ul></li>
<li><code>ReceiptsRoot</code> - To compute this:

<ul>
<li>Apply the set of messages to the parent state as described above, collecting invocation receipts as this happens.</li>
<li>Insert them into a sharray and take its root.</li>
</ul></li>
<li><code>Timestamp</code> - A Unix Timestamp generated at block creation. We use an unsigned integer to represent a UTC timestamp (in seconds). The Timestamp in the newly created block must satisfy the following conditions:

<ul>
<li>the timestamp on the block is not in the future (with ALLOWABLE_CLOCK_DRIFT grace to account for relative asynchrony)</li>
<li>the timestamp on the block is at least BLOCK_DELAY * len(block.Tickets) higher than the latest of its parents, with BLOCK_DELAY taking on the same value as that needed to generate a valid VDF proof for a new Ticket (currently set to 30 seconds).</li>
<li>We also recommend the use of a networkTime() function to be booted on node launch and run every so frequently to call on a networked time service (e.g. ntp) and ensure relative synchrony with the rest of the network.</li>
</ul></li>
<li><code>BlockSig</code> - A signature with the miner&rsquo;s private key (must also match the ticket signature) over the entire block. This is to ensure that nobody tampers with the block after it propagates to the network, since unlike normal PoW blockchains, a winning ticket is found independently of block generation.</li>
</ul>

<p>An eligible miner can start by filling out <code>Parents</code>, <code>Tickets</code> and <code>ElectionProof</code> with values from the ticket checking process.</p>

<p>Next, they compute the aggregate state of their selected parent blocks, the <code>ParentState</code>. This is done by taking the aggregate parent state of the blocks&rsquo; parent TipSet, sorting the parent blocks by their tickets, and applying each message in each block to that state. Any message whose nonce is already used (duplicate message) in an earlier block should be skipped (application of this message should fail anyway). Note that re-applied messages may result in different receipts than they produced in their original blocks, an open question is how to represent the receipt trie of this tipsets &lsquo;virtual block&rsquo;. For more details on message execution and state transitions, see the <a href="../state-machine">Filecoin state machine</a> document.</p>

<p>Once the miner has the aggregate <code>ParentState</code>, they must apply the block reward. This is done by adding the correct block reward amount to the miner owner&rsquo;s account balance in the state tree. The reward will be spendable immediately in this block. See <a href="#block-rewards">block reward</a> for details on how the block reward is structured. See <a href="#notes-on-block-reward-application">Notes on Block Reward Application</a> for some of the nuances in applying block rewards.</p>

<p>Now, a set of messages is selected to put into the block. For each message, the miner subtracts <code>msg.GasPrice * msg.GasLimit</code> from the sender&rsquo;s account balance, returning a fatal processing error if the sender does not have enough funds (this message should not be included in the chain).</p>

<p>They then apply the messages state transition, and generate a receipt for it containing the total gas actually used by the execution, the executions exit code, and the return value (see <a href="../data-structures#message-receipt">receipt</a> for more details). Then, they refund the sender in the amount of <code>(msg.GasLimit - GasUsed) * msg.GasPrice</code>. In the event of a message processing error, the remaining gas is refunded to the user, and all other state changes are reverted. (Note: this is a divergence from the way things are done in Ethereum)</p>

<p>Each message should be applied on the resultant state of the previous message execution, unless that message execution failed, in which case all state changes caused by that message are thrown out. The final state tree after this process will be the block&rsquo;s <code>StateRoot</code>.</p>

<p>The miner merklizes the set of messages selected, and put the root in <code>MsgRoot</code>. They gather the receipts from each execution into a set, merklize them, and put that root in <code>ReceiptsRoot</code>. Finally, they set the <code>StateRoot</code> field with the resultant state.</p>

<div class="notices info" >Note that the <code>ParentState</code> field from the expected consensus document is left out, this is to help minimize the size of the block header. The parent state for any given parent set should be computed by the client and cached locally.</div>

<p>Finally, the miner can generate a Unix Timestamp to add to their block, to show that the block generation was appropriately delayed.</p>

<p>The miner will wait until BLOCK_DELAY has passed since the latest block in the parent set was generated to timestamp and send out their block. We recommend using NTP or another clock synchronization protocol to ensure that the timestamp is correctly generated (lest the block be rejected). While this timestamp does not provide a hard proof that the block was delayed (we rely on the VDF in the ticket-chain to do so), it provides some softer form of block delay by ensuring that honest miners will reject undelayed blocks.</p>

<p>Now the block is complete, all that&rsquo;s left is to sign it. The miner serializes the block now (without the signature field), takes the sha256 hash of it, and signs that hash. They place the resultant signature in the <code>BlockSig</code> field.</p>

<h4 id="block-broadcast">Block Broadcast</h4>

<p>An eligible miner broadcasts the completed block to the network (via <a href="../data-propagation">block propagation</a>), and assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p>

<h3 id="block-rewards">Block Rewards</h3>

<p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin). These funds are initially held by the network account actor, and are transferred to miners in blocks that they mine. The reward amount remains fixed for a period of 1 week (given our 30 second block time, this  is 20,160 blocks, the <code>AdjustmentPeriod</code>) and is then adjusted. Over time, the reward will eventually become zero as the fractional amount given out at each step shrinks the network account&rsquo;s balance to 0.</p>

<p>The equation for the current block reward is of the form:</p>

<pre><code>Reward = IV * (Decay ^ (BlockHeight / 20160))
</code></pre>

<p><code>IV</code> is the initial value, and is computed by taking:</p>

<pre><code>IV = TotalIssuance * (1 - Decay)
</code></pre>

<p><code>Decay</code> is computed by:</p>

<pre><code>Decay = e^(ln(0.5) / (HalvingPeriodBlocks / AdjustmentPeriod))
</code></pre>

<pre><code>// Given one block every 30 seconds, this is how many blocks are in six years
HalvingPeriodBlocks = 6 * 365 * 24 * 60 * 2 = 6,307,200 blocks
</code></pre>

<p>Note: Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it&rsquo;s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</p>

<p>TODO: Ensure that if a miner earns a block reward while undercollateralized, then <code>min(blockReward, requiredCollateral-availableBalance)</code> is garnished (transfered to the miner actor instead of the owner).</p>

<h3 id="notes-on-block-reward-application">Notes on Block Reward Application</h3>

<p>As mentioned above, every round, a miner checks to see if they have been selected as the leader for that particular round (see <a href="../expected-consensus#secret-leader-election">Secret Leader Election</a> in the Expected Consensus spec for more detail). Thus, it is possible that multiple miners may be selected as winners in a given round, and thus, that there will be multiple blocks with the same parents that are produced at the same block height (forming a TipSet). Each of the winning miners will apply the block reward directly to their actor&rsquo;s state in their state tree.</p>

<p>Other nodes will receive these blocks and form a TipSet out of the eligible blocks (those that have the same parents and are at the same block height). These nodes will then validate the TipSet. The full procedure for how to verify a TipSet can be found above in <a href="#block-validation">Block Validation</a>. To validate TipSet state, the validating node will, for each block in the TipSet, first apply the block reward value directly to the mining node&rsquo;s account and then apply the messages contained in the block.</p>

<p>Thus, each of the miners who produced a block in the TipSet will receive a block reward. There will be no lockup. These rewards can be spent immediately.</p>

<p>Messages in Filecoin also have an associated transaction fee (based on the gas costs of executing the message). In the case where multiple winning miners included the same message in their blocks, only the first miner will be paid this transaction fee. The first miner is the miner with the lowest ticket value (sorted lexicographically). More details on message execution can be found in the <a href="../state-machine#execution-calling-a-method-on-an-actor">State Machine spec</a>.</p>

<h3 id="open-questions">Open Questions</h3>

<ul>
<li>How should receipts for tipsets &lsquo;virtual blocks&rsquo; be referenced? It is common for applications to provide the merkleproof of a receipt to prove that a transaction was successfully executed.</li>
</ul>

<h3 id="future-work">Future Work</h3>

<p>There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future.</p>

<ul>
<li><strong>Sector Resealing</strong>: Miners should be able to &rsquo;re-seal&rsquo; sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not-yet-expired pieces into a single (or multiple) sectors.</li>
<li><strong>Sector Transfer</strong>: Miners should be able to re-delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road.</li>
</ul>

</article>

      
<div class="align-center book-git-footer justify-end">
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/mining.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#what-is-the-filecoin-mining-process">What is the Filecoin Mining Process</a></li>
</ul></li>
<li><a href="#the-miner-actor">The Miner Actor</a>
<ul>
<li><a href="#owner-worker-distinction">Owner Worker distinction</a></li>
<li><a href="#storage-mining-cycle">Storage Mining Cycle</a>
<ul>
<li><a href="#step-0-registration">Step 0: Registration</a></li>
<li><a href="#step-1-commit">Step 1: Commit</a></li>
<li><a href="#step-2-proving-storage-post-creation">Step 2: Proving Storage (PoSt creation)</a></li>
<li><a href="#step-3-post-submission">Step 3: PoSt Submission</a></li>
</ul></li>
<li><a href="#stop-mining">Stop Mining</a></li>
<li><a href="#faults">Faults</a></li>
<li><a href="#on-being-slashed-wip-needs-discussion">On Being Slashed (WIP, needs discussion)</a></li>
</ul></li>
<li><a href="#mining-blocks">Mining Blocks</a>
<ul>
<li><a href="#receiving-blocks">Receiving Blocks</a></li>
<li><a href="#block-validation">Block Validation</a></li>
<li><a href="#ticket-validation">Ticket Validation</a></li>
<li><a href="#election-validation">Election Validation</a></li>
<li><a href="#ticket-generation">Ticket Generation</a></li>
<li><a href="#block-creation">Block Creation</a>
<ul>
<li><a href="#block-broadcast">Block Broadcast</a></li>
</ul></li>
<li><a href="#block-rewards">Block Rewards</a></li>
<li><a href="#notes-on-block-reward-application">Notes on Block Reward Application</a></li>
<li><a href="#open-questions">Open Questions</a></li>
<li><a href="#future-work">Future Work</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
