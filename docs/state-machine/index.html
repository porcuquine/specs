<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    State Machine
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->


  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fstate-machine\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><a href="../../docs/proofs/"><strong>Proofs</strong></a></p>

<ul>
<li><a href="../../docs/zigzag-porep/">Proof-of-Replication</a>

<ul>
<li><a href="../../docs/zigzag-commitments/">ZigZag Commitments</a></li>
<li><a href="../../docs/zigzag-circuit/">Circuit</a></li>
</ul></li>
<li><a href="../../docs/proof-of-spacetime/">Proof-of-Spacetime</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    State Machine
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="the-filecoin-state-machine">The Filecoin State Machine</h1>

<p>The majority of Filecoin&rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin State Machine. The network generates a series of blocks, and agrees which &lsquo;chain&rsquo; of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p>

<p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p>

<p>An <code>actor</code> is the Filecoin equivalent of Ethereum&rsquo;s smart contracts, it is essentially an &lsquo;object&rsquo; in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p>

<h3 id="method-invocation">Method Invocation</h3>

<p>There are two routes to calling a method on an <code>actor</code>.</p>

<p>First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>.  The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of &lsquo;gas&rsquo;. We also use &lsquo;gas&rsquo;).</p>

<p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods.  However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p>

<h3 id="sending-funds">Sending Funds</h3>

<p>As all messages carry a method ID, the method ID &lsquo;0&rsquo; is reserved for simple
transfers of funds. Funds specified by the value field are always transferred,
but specifying a method ID of &lsquo;0&rsquo; ensures that no other side effects occur.</p>

<h3 id="state-representation">State Representation</h3>

<p>The <code>global state</code> is modeled as a map of actor <code>ID</code>s to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the &lsquo;key&rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the <code>InitActor</code>), and the value is an <a href="../data-structures#actor"><code>Actor</code></a> object with the actors information. Within each <code>Actor</code> object is a field called <code>state</code> that is an ipld pointer to a graph that can be entirely defined by the actor.</p>

<h3 id="actor-creation">Actor Creation</h3>

<p>There are two mechanisms by which an actor can be created. By explicitly invoking <code>exec</code> on the <code>Init</code> actor, and by sending a message to a <code>Public Key</code> typed <code>Address</code>.</p>

<p>Calling <code>exec</code> to create an actor should generate an Actor address, and register it in the state tree (see <a href="../actors#init-actor">Init Actor</a> for more details).</p>

<p>Sending a message to a non-existant account via a public key address causes the creation of an account actor for that address. The <code>To</code> address should be placed into the actor storage for later use in validating messages sent from this actor.</p>

<p>This second route for creating an actor is allowed to avoid the necessity of an explicit &lsquo;register account&rsquo; step for creating new accounts.</p>

<h3 id="execution-calling-a-method-on-an-actor">Execution (Calling a method on an Actor)</h3>

<p>Message execution currently relies entirely on &lsquo;built-in&rsquo; code, with a common external interface. The method and actor to call it on are specified in the <code>Method</code> and <code>To</code> fields of a message, respectively. Method parameters are encoded and put into the <code>Params</code> field of a message. The encoding is technically actor dependent, but for all built-in Filecoin actors it is the dag-cbor ipld encoding of the parameters struct for each method defined in <a href="../actors">the actors doc</a>.</p>

<p>These functions are given, as input, an <code>ExecutionContext</code> containing useful information for their execution.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">VMContext</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Message is the message that kicked off the current invocation
</span><span class="c1"></span>    <span class="nf">Message</span><span class="p">()</span> <span class="nx">Message</span>

    <span class="c1">// Storage provides access to the VM storage layer
</span><span class="c1"></span>    <span class="nf">Storage</span><span class="p">()</span> <span class="nx">Storage</span>

    <span class="c1">// Origin is the address of the account that initiated the top level invocation
</span><span class="c1"></span>    <span class="nf">Origin</span><span class="p">()</span> <span class="nx">Address</span>

    <span class="c1">// Send allows the current execution context to invoke methods on other actors in the system
</span><span class="c1"></span>    <span class="nf">Send</span><span class="p">(</span><span class="nx">to</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">AttoFIL</span><span class="p">,</span> <span class="nx">params</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// BlockHeight returns the height of the block this message was added to the chain in
</span><span class="c1"></span>    <span class="nf">BlockHeight</span><span class="p">()</span> <span class="nx">BlockHeight</span>
<span class="p">}</span></code></pre></div>
<p>If the execution completes successfully, changes to the state tree are saved. Otherwise, the message is marked as failed, and any state changes are reverted.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">st</span> <span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msg</span> <span class="nx">Message</span><span class="p">)</span> <span class="nx">MessageReceipt</span> <span class="p">{</span>
    <span class="nx">st</span><span class="p">.</span><span class="nf">Snapshot</span><span class="p">()</span>
    <span class="nx">fromActor</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no such from actor&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">totalCost</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasLimit</span> <span class="o">*</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nx">Balance</span> <span class="p">&lt;</span> <span class="nx">totalCost</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough funds&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">Nonce</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nx">Nonce</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid nonce&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">toActor</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
        <span class="nx">toActor</span> <span class="p">=</span> <span class="nf">TryCreateAccountActor</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">st</span><span class="p">.</span><span class="nf">DeductFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">totalCost</span><span class="p">)</span>
    <span class="nx">st</span><span class="p">.</span><span class="nf">DepositFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>

    <span class="nx">vmctx</span> <span class="o">:=</span> <span class="nf">makeVMContext</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">ret</span><span class="p">,</span> <span class="nx">errcode</span> <span class="o">:=</span> <span class="nx">toActor</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">vmctx</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">errcode</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// revert all state changes since snapshot
</span><span class="c1"></span>            <span class="nx">st</span><span class="p">.</span><span class="nf">Revert</span><span class="p">()</span>
            <span class="nx">st</span><span class="p">.</span><span class="nf">DeductFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">()</span><span class="o">*</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// refund unused gas
</span><span class="c1"></span>            <span class="nx">st</span><span class="p">.</span><span class="nf">DepositFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasLimit</span><span class="o">-</span><span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">())</span><span class="o">*</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// reward miner gas fees
</span><span class="c1"></span>    <span class="nx">st</span><span class="p">.</span><span class="nf">DepositFunds</span><span class="p">(</span><span class="nx">BlockMiner</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="o">*</span><span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">())</span>

    <span class="k">return</span> <span class="nx">MessageReceipt</span><span class="p">{</span>
        <span class="nx">ExitCode</span><span class="p">:</span> <span class="nx">errcode</span><span class="p">,</span>
        <span class="nx">Return</span><span class="p">:</span>   <span class="nx">ret</span><span class="p">,</span>
        <span class="nx">GasUsed</span><span class="p">:</span>  <span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">(),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TryCreateAccountActor</span><span class="p">(</span><span class="nx">st</span> <span class="nx">StateTree</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">Actor</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">BLS</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">NewBLSAccountActor</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Secp256k1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">NewSecp256k1AccountActor</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">ID</span><span class="p">:</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no actor with given ID&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Actor</span><span class="p">:</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no such actor&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="receipts">Receipts</h4>

<p>Every message execution generates a <a href="../data-structures#message-receipt">receipt</a>. These receipts contain the encoded return value of the method invocation, and an exit code.</p>

<h4 id="storage">Storage</h4>

<p>Actors are given acess to a <code>Storage</code> interface to fulfil their need for persistent storage. The <code>Storage</code> interface describes a content addressed block storage system (<code>Put</code> and <code>Get</code>) and a pointer into it (<code>Head</code> and <code>Commit</code>) that points to the actor&rsquo;s current state.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Storage</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Put writes the given object to the storage staging area and returns its CID
</span><span class="c1"></span>    <span class="nf">Put</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">Cid</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// Get fetches the given object from storage (either staging, or local) and returns
</span><span class="c1"></span>    <span class="c1">// the serialized data.
</span><span class="c1"></span>    <span class="nf">Get</span><span class="p">(</span><span class="nx">Cid</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// Commit updates the actual stored state for the actor. This is a compare and swap
</span><span class="c1"></span>    <span class="c1">// operation, and will fail if &#39;old&#39; is not equal to the current return value of `Head`.
</span><span class="c1"></span>    <span class="c1">// This functionality is used to prevent issues with re-entrancy
</span><span class="c1"></span>    <span class="nf">Commit</span><span class="p">(</span><span class="nx">old</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">Cid</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// Head returns the CID of the current actor state
</span><span class="c1"></span>    <span class="nf">Head</span><span class="p">()</span> <span class="nx">Cid</span>
<span class="p">}</span></code></pre></div>
<p>Actors can store state as a single block or implement any persistent
data structure that can be built upon a content addressed block store.
Implementations may provide data structure implementations to simplify
development. The current interface only supports CBOR-IPLD, but this
should soon expand to allow other types of IPLD data structures (as long
as the system has resolvers for them).</p>

<p>The current state of a given actor can be accessed first by calling <code>Head</code> to retrieve the CID of the root of the actors state, then by using <code>Get</code> to retrieve the actual object being referenced.</p>

<p>To store data, <code>Put</code> is used. Any number of objects may be <code>Put</code>, but only the object whose CID is committed, or objects that are linked to in some way by the committed object will be kept. All other objects are dropped after the method invocation returns. Objects stored via <code>Put</code> are first marshaled to CBOR-IPLD, and then stored, the returned CID is a 32 byte sha2-256 CBOR-IPLD content identifier.</p>

<h3 id="burning-funds">Burning Funds</h3>

<p>In the case that an actor needs to provably burn funds, the funds should be transferred to the &lsquo;Burnt Funds Actor&rsquo; (ID 99).</p>

</article>

      
<div class="align-center book-git-footer justify-end">
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/state-machine.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#the-filecoin-state-machine">The Filecoin State Machine</a>
<ul>
<li>
<ul>
<li><a href="#method-invocation">Method Invocation</a></li>
<li><a href="#sending-funds">Sending Funds</a></li>
<li><a href="#state-representation">State Representation</a></li>
<li><a href="#actor-creation">Actor Creation</a></li>
<li><a href="#execution-calling-a-method-on-an-actor">Execution (Calling a method on an Actor)</a>
<ul>
<li><a href="#receipts">Receipts</a></li>
<li><a href="#storage">Storage</a></li>
</ul></li>
<li><a href="#burning-funds">Burning Funds</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
