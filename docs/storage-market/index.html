<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Storage Market
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->


  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fstorage-market\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><a href="../../docs/proofs/"><strong>Proofs</strong></a></p>

<ul>
<li><a href="../../docs/zigzag-porep/">Proof-of-Replication</a>

<ul>
<li><a href="../../docs/zigzag-commitments/">ZigZag Commitments</a></li>
<li><a href="../../docs/zigzag-circuit/">Circuit</a></li>
</ul></li>
<li><a href="../../docs/proof-of-spacetime/">Proof-of-Spacetime</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Storage Market
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="the-filecoin-storage-market">The Filecoin Storage Market</h1>

<h3 id="what-is-the-filecoin-storage-market">What is the Filecoin Storage Market</h3>

<p>The Filecoin <code>storage market</code> is the underlying system used to discover, negotiate and form <code>storage contracts</code> between clients and storage providers called <code>storage miners</code> in a Filecoin network. The <code>storage market</code> itself is an <code>actor</code> that helps to mediate certain operations in the market, including adding new miners, and punishing faulty ones, it does not directly mediate any actual storage deals. The <code>storage contracts</code> between clients and miners specify that a given <code>piece</code> will be stored for a given time duration. It is assumed that the <code>client</code>, or some delegate of the client, remains online to monitor the <code>storage miner</code> and <code>slash</code> it in the case that the agreed upon data is removed from the miners proving set before the deal is finished.</p>

<p>The creation of such a storage market is motivated by the need to provide a fast, reliable and inexpensive solution to data generated worldwide. The cost and difficulty involved in starting datacenters around the world make a decentralized solution attractive here, enabling clients and miners to interact directly, forming agreements for storage ad-hoc around the world. Geography is only one such aspect in which a decentralized market can be made competitive. You can read more about the underlying motivations for building a storage market <a href="https://www.youtube.com/watch?v=EClPAFPeXIQ">here</a>.</p>

<p>In the current design of the <code>storage market</code>, <code>storage miners</code> post <code>asks</code> indicating the price they are willing to accepts, and <code>clients</code> select (either manually, or via some locally run algorithm) a set of storage miners to store their data with. They then contact the <code>storage miners</code> who programmatically either accept or deny their <code>deal proposals</code>. In the future, we may allow miners to search for clients and propose deals to them, but for now, for simplicity, we stick with the model described above.</p>

<h3 id="visualization-of-the-filecoin-storage-market">Visualization of the Filecoin Storage Market</h3>

<p>TODO: This is a high level overview of how the storage market interacts with components</p>

<h2 id="the-market-interface">The Market Interface</h2>

<p>This interface, written using Go type notation, defines the set of methods that are callable on the storage market actor. The storage market actor is a built-in network actor. For more information about Actors, see <a href="../actors">actors.md</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StorageMarket</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// CreateStorageMiner registers a new storage miner with the given public key and a
</span><span class="c1"></span>    <span class="c1">// pledge of the given size. The miners collateral is set by the value in the message.
</span><span class="c1"></span>    <span class="c1">// The public key must match the private key used to sign off on blocks created
</span><span class="c1"></span>    <span class="c1">// by this miner. This key is the &#39;worker&#39; key for the miner.
</span><span class="c1"></span>    <span class="c1">// The libp2p peer ID specified should reference the libp2p identity that the
</span><span class="c1"></span>    <span class="c1">// miner is operating. This is the ID that clients will connect to to propose deals
</span><span class="c1"></span>    <span class="c1">// TODO: maybe rename to &#39;RegisterStorageMiner&#39;?
</span><span class="c1"></span>    <span class="nf">CreateStorageMiner</span><span class="p">(</span><span class="nx">pubk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">pledge</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span><span class="p">)</span> <span class="nx">Address</span>

    <span class="c1">// SlashConsensusFault is used to slash a misbehaving miner who submitted two different
</span><span class="c1"></span>    <span class="c1">// blocks at the same block height. The signatures on each block are validated
</span><span class="c1"></span>    <span class="c1">// and the offending miner has their entire collateral slashed, including the
</span><span class="c1"></span>    <span class="c1">// invalidation of any any all storage they are providing. The caller is rewarded
</span><span class="c1"></span>    <span class="c1">// a small amount to compensate for gas fees (TODO: maybe it should be more?)
</span><span class="c1"></span>    <span class="nf">SlashConsensusFault</span><span class="p">(</span><span class="nx">blk1</span><span class="p">,</span> <span class="nx">blk2</span> <span class="nx">BlockHeader</span><span class="p">)</span>

    <span class="c1">// SlashStorageFault slashes a storage miner for not submitting their PoSTs within
</span><span class="c1"></span>    <span class="c1">// the correct [time window](#TODO-link-to-faulty-submission). This may be called by anyone who detects the faulty behavior.
</span><span class="c1"></span>    <span class="c1">// The slashed miner then loses all of their staked collateral, and also loses all
</span><span class="c1"></span>    <span class="c1">// of their power, and as a result, is no longer a candidate leader for extending the chain.
</span><span class="c1"></span>    <span class="nf">SlashStorageFault</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">Address</span><span class="p">)</span>

    <span class="c1">// UpdateStorage is called by a miner to adjust the storage market actors
</span><span class="c1"></span>    <span class="c1">// accounting of the total storage in the storage market.
</span><span class="c1"></span>    <span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">delta</span> <span class="nx">BytesAmount</span><span class="p">)</span>

    <span class="c1">// GetTotalStorage returns the total committed storage in the system. This number is
</span><span class="c1"></span>    <span class="c1">// also used as the &#39;total power&#39; in the system for the purposes of the power table
</span><span class="c1"></span>    <span class="nf">GetTotalStorage</span><span class="p">()</span> <span class="nx">BytesAmount</span>
<span class="p">}</span></code></pre></div>
<h2 id="the-filecoin-storage-market-operation">The Filecoin Storage Market Operation</h2>

<p>The Filecoin storage market operates as follows. Miners providing storage submit ask orders, asking for a certain price for their available storage space, and clients with files to store look through the asks and select a miner they wish to use. Clients negotiate directly with the storage miner that owns that ask, off-chain. Storage is priced in terms of Filecoin per byte per block (note: we may change the units here).</p>

<h3 id="market-datastructures">Market Datastructures</h3>

<p>The storage market contains the following data:</p>

<ul>
<li>StorageMiners - The storage market keeps track of the set of the addresses of all storage miners in the storage market. All miners referenced here were created by the storage market via the <code>CreateStorageMiner</code> method.</li>
<li>TotalComittedStorage - This is a tally of all the committed storage in the network. This is both a nice metric to see how much data is being stored by the filecoin network, and a critical piece of information used by mining routine to compute each miners storage ratio.</li>
</ul>

<h2 id="market-flow">Market Flow</h2>

<p>This section describes the flow required to store a single piece with a single storage miner. Most use-cases will involve performing this process for multiple pieces, with different miners.</p>

<h4 id="before-deal">Before Deal</h4>

<ol>
<li><strong>Data Preparation:</strong> The client prepares their input data. See <a href="../client-data">client data</a> for more details.</li>
<li><strong>Miner Selection:</strong> The client looks at asks on the network, and then selects a storage miner to store their data with.

<ul>
<li>Note: this is currently a manual process.</li>
</ul></li>
<li><strong>Payment Channel Setup:</strong> The client calls <a href="#payments"><code>Payment.Setup</code></a> with the piece and the funds they are going to pay the miner with. All payments between clients and storage providers use payment channels.</li>
</ol>

<h4 id="deal">Deal</h4>

<p>Note: The details of this protocol including formats, datastructures, and algorithms, can be found <a href="../network-protocols#storage-deal">here</a>.</p>

<ol>
<li><p><strong>Storage Deal Staging:</strong> The client now runs the <a href="../network-protocols#storage-deal">&lsquo;make storage deal&rsquo;</a> protocol, as follows:</p>

<ul>
<li>The client sends a <code>StorageDealProposal</code> for the piece in question</li>
<li>This contains updates for the payment channel that the client may close at any time, unless the piece gets confirmed (see next section), in which case the miner is able to extend the channel.</li>
<li>The miner decides whether or not to accept the deal and sends back a <code>StorageDealResponse</code></li>
<li>Note: Different implementations may come up with different ways of making a decision on a given deal.</li>
<li>If the miner accepts, the client now sends the data to the miner</li>
<li>Once the miner receives the data:</li>
<li>They validate that the data matches the storage market hash claimed by the client</li>
<li>They stage it into a sector and set the deal state to <code>Staged</code></li>
</ul></li>

<li><p><strong>Storage Deal Start</strong>: Clients makes sure data is in a <a href="../definitions#sector">sector</a></p>

<ul>
<li><strong>PieceInclusionProof:</strong> Once the miner seals the sector, they update the PieceInclusionProof in the deal state, which the client then gets the next time they query that state.

<ul>
<li>The PieceInclusionProof proves that the piece in the deal is contained in a sector whose commitment is on chain. The <code>commP</code> hash from earlier is used here. See <a href="../proofs#piece-inclusion-proof">piece inclusion proof for more details</a></li>
</ul></li>
<li>Note: a client that is not interested in staying online to wait for PieceInclusionProof can leave immediately, however, they run the risk that their files don&rsquo;t actually get stored (but if their data is not stored, the miner will not be able to claim payment for it).

<ul>
<li>Note: In order to provide the piece inclusion proof, the miner needs to fill the sector. This may take some time. So there is a wait between the time the data is transferred to the miner, and when the piece inclusion proof becomes available.</li>
</ul></li>
<li><strong>Mining</strong>: Miner posts <code>seal commitment</code> and associated proof on chain by calling <code>CommitSector</code> and starts running <code>proofs of spacetime</code>. See <a href="../mining#storage-mining-cycle">storage mining cycle</a> for more details.</li>
</ul></li>

<li><p><strong>Storage Deal Abort:</strong> If the miner doesn&rsquo;t provide the PieceInclusionProof, the client can invalidate the payment channel.</p>

<ul>
<li>This is done by invoking the &lsquo;close&rsquo; method on the channel on-chain. This process starts a timer that, on finishing, will release the funds to the client.</li>
<li>If a client attempts to abort a deal that they have actually made with a miner, the miner can submit a payment channel update to force the channel to stay open for the length of the agreement.</li>
</ul></li>

<li><p><strong>Storage Deal Complete:</strong> The client periodically queries the miner for the deals status until the deal is &lsquo;complete&rsquo;, at which point the client knows that the data is properly replicated.</p>

<ul>
<li>The client should store the returned &lsquo;PieceInclusionProof&rsquo; for later validation.</li>
</ul></li>
</ol>

<p>TODO: &lsquo;complete&rsquo; isnt really the right word here, as it implies that the deal is over.</p>

<ol>
<li><strong>Income Withdrawal</strong>: When the miner wishes to withdraw funds, they call <a href="#payments"><code>Payment.RedeemVoucher</code></a>.</li>
</ol>

<h2 id="the-power-table">The Power Table</h2>

<p>The <code>power table</code> is exported by the storage market for use by consensus. There isn&rsquo;t actually a concrete object that is the power table (though the concept is conceptually helpful), instead, the <a href="../actors#storage-market-actor">storage market actor</a> exports the <code>GetTotalStorage</code> and <code>PowerLookup</code>  methods which can be used to lookup total network power and a miner&rsquo;s power, respectively.
Each individual miner reports its power through their actor.</p>

<p>To check the power of a given miner, use the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetMinersPowerAt</span><span class="p">(</span><span class="nx">ts</span> <span class="nx">TipSet</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">Integer</span> <span class="p">{</span>
  <span class="nx">curState</span> <span class="o">:=</span> <span class="nf">GetStateTree</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
  <span class="nx">miner</span> <span class="o">:=</span> <span class="nx">curState</span><span class="p">.</span><span class="nf">GetMiner</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">IsSlashed</span><span class="p">()</span> <span class="o">||</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">IsLate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
  
  <span class="err">#</span> <span class="nx">lookback</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">valid</span> <span class="nx">PoSt</span> <span class="nx">put</span> <span class="nx">up</span> <span class="nx">by</span> <span class="nx">the</span> <span class="nx">miner</span>
  <span class="nx">lookbackTipset</span> <span class="o">:=</span> <span class="nf">WalkBack</span><span class="p">(</span><span class="nx">ts</span><span class="p">,</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">provingPeriodEnd</span> <span class="o">-</span> <span class="nf">provingPeriodDuration</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">))</span>
  <span class="nx">lbState</span> <span class="o">:=</span> <span class="nf">GetStateTree</span><span class="p">(</span><span class="nx">lookbackTipset</span><span class="p">)</span>
  
  <span class="nx">sm</span> <span class="o">:=</span> <span class="nx">lbState</span><span class="p">.</span><span class="nf">GetStorageMarket</span><span class="p">()</span>
  
  <span class="k">return</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">PowerLookup</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h3 id="power-updates">Power Updates</h3>

<p>Whenever a new <a href="../proofs">PoSt</a> or <a href="../faults">Fault</a> makes it on chain, the storage market updates the underlying power values appropriately.</p>

<p>Specifically, a miner&rsquo;s power is initialized/maintained when they <a href="../actors#submitPoSt">submit a valid PoSt</a> to the chain, and decreases if they are slashed (for a <a href="actors.md#slashStorageFault">storage fault</a> or a <a href="actors.md#slashConsensusFault">consensus fault</a>).</p>

<p>Power is deducted when miners remove sectors by reporting the sector &lsquo;missing&rsquo; or &lsquo;done&rsquo; in a PoSt.</p>

<h2 id="payments">Payments</h2>

<p>The storage market expects a payments system to allow clients to pay miners for storage. Any payments system that has the following capabilities may be used:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Payments</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Setup sets up a payment from the caller to the target address. The payment
</span><span class="c1"></span>    <span class="c1">// MUST be contingent on the miner being able to prove that they have the data
</span><span class="c1"></span>    <span class="c1">// referenced by &#39;piece&#39;. The total amount of Filecoin that may be transfered by
</span><span class="c1"></span>    <span class="c1">// this payment is specified by &#39;value&#39;
</span><span class="c1"></span>    <span class="nf">Setup</span><span class="p">(</span><span class="nx">target</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">piece</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">ID</span>

    <span class="c1">// MakeVouchers creates a set of vouchers redeemable by the target of the
</span><span class="c1"></span>    <span class="c1">// previously created payment. It creates &#39;count&#39; vouchers, each of which is
</span><span class="c1"></span>    <span class="c1">// redeemable only after an certain block height, evenly spaced out between
</span><span class="c1"></span>    <span class="c1">// start and end. Each voucher should be redeemable for proportionally more
</span><span class="c1"></span>    <span class="c1">// Filecoin, up to the total amount specified during the payment setup.
</span><span class="c1"></span>    <span class="nf">MakeVouchers</span><span class="p">(</span><span class="nx">id</span> <span class="nx">ID</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">BlockHeight</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Voucher</span>

    <span class="c1">// Redeem voucher is called by the target of a given payment to claim the
</span><span class="c1"></span>    <span class="c1">// funds represented by it. The voucher can only be redeemed after the block
</span><span class="c1"></span>    <span class="c1">// height that is attributed to the voucher, and also only if the proof given
</span><span class="c1"></span>    <span class="c1">// proves that the target is correctly storing the piece referenced in the
</span><span class="c1"></span>    <span class="c1">// payment setup.
</span><span class="c1"></span>    <span class="nf">RedeemVoucher</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Voucher</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">Proof</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>For details on the implementation of the payments system, see <a href="../payments">the payments doc</a>.</p>

<h2 id="future-protocol-improvements">Future Protocol Improvements</h2>

<ul>
<li>Slashable Commitments

<ul>
<li>When miners initially receive the data for a deal with a client, that signed response statement can be used to slash the miner in the event that they never include that data in a sector.</li>
</ul></li>
</ul>

<h1 id="open-questions">Open questions</h1>

<ul>
<li>Storage time should likely be designated in terms of proving period. Where a proving period is the number of blocks in which every miner must submit a proof for their sectors. Not doing this makes accounting hard: &ldquo;when exactly did this sector fail?&rdquo;</li>
</ul>

</article>

      
<div class="align-center book-git-footer justify-end">
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/storage-market.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#the-filecoin-storage-market">The Filecoin Storage Market</a>
<ul>
<li>
<ul>
<li><a href="#what-is-the-filecoin-storage-market">What is the Filecoin Storage Market</a></li>
<li><a href="#visualization-of-the-filecoin-storage-market">Visualization of the Filecoin Storage Market</a></li>
</ul></li>
<li><a href="#the-market-interface">The Market Interface</a></li>
<li><a href="#the-filecoin-storage-market-operation">The Filecoin Storage Market Operation</a>
<ul>
<li><a href="#market-datastructures">Market Datastructures</a></li>
</ul></li>
<li><a href="#market-flow">Market Flow</a>
<ul>
<li>
<ul>
<li><a href="#before-deal">Before Deal</a></li>
<li><a href="#deal">Deal</a></li>
</ul></li>
</ul></li>
<li><a href="#the-power-table">The Power Table</a>
<ul>
<li><a href="#power-updates">Power Updates</a></li>
</ul></li>
<li><a href="#payments">Payments</a></li>
<li><a href="#future-protocol-improvements">Future Protocol Improvements</a></li>
</ul></li>
<li><a href="#open-questions">Open questions</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
