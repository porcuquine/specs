<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Zigzag Porep
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->


  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fzigzag-porep\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><a href="../../docs/proofs/"><strong>Proofs</strong></a></p>

<ul>
<li><a href="../../docs/zigzag-porep/">Proof-of-Replication</a>

<ul>
<li><a href="../../docs/zigzag-commitments/">ZigZag Commitments</a></li>
<li><a href="../../docs/zigzag-circuit/">Circuit</a></li>
</ul></li>
<li><a href="../../docs/proof-of-spacetime/">Proof-of-Spacetime</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Zigzag Porep
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="proof-of-replication">Proof-of-Replication</h1>

<p>This spec describes the specific Proof-of-Replication used in Filecoin called <em>ZigZag</em>.</p>

<p>ZigZag has been presented by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.</p>

<h2 id="introduction">Introduction</h2>

<h3 id="background-on-proof-of-replication">Background on Proof-of-Replication</h3>

<p><em>Proof-of-Replication</em> enables a prover <em>P</em> to convince a verifier <em>V</em> that <em>P</em> is storing a replica <em>R</em>, a physically independent copy of some data <em>D</em>, unique to <em>P</em>. The scheme is defined by a tuple of polynomial time algorithms (<em>Setup</em>, Replication, <em>Prove</em>, <em>Verify</em>). The assumption is that generation of a replica after <em>Replicate</em>  must be difficult (if not impossible) to generate.</p>

<ul>
<li><em>Setup</em>: On setup, the public parameters of the proving systems are set.</li>
<li><em>Replicate</em>: On replication, either a party or both (depending on the scheme, in our case the prover only!) generate a unique permutation of the original data <em>D</em>, which we call replica <em>R</em>.</li>
<li><em>Prove</em>: On receiving a challenge, the prover must generate a proof that it is in possession of the replica and that it was derived from data <em>D</em>. The prover must only be able to respond to the challenge successfully if it is in possession of the replica, since would be difficult (if not impossible) to generate a replica that can be used to generate the proof at this stage</li>
<li><em>Verify</em>: On receiving the proof, the verifier checks the validity of the proof and accepts or rejects the proof.</li>
</ul>

<div class="mermaid" align="center">
sequenceDiagram
    Note right of Prover: CommD
    Prover-->>Prover: R, CommR ← Replicate(D) 
    Prover->>Verifier: CommR
    Verifier-->>Verifier: Generate random challenge
    Verifier->>Prover: challenge
    Prover-->>Prover: proof ← Prove(D, R, challenge)
    Prover->>Verifier: proof
</div>

<h4 id="time-bounded-proof-of-replication">Time-bounded Proof-of-Replication</h4>

<p><strong>Timing assumption</strong>. <em>Time-bounded Proof-of-Replication</em> are constructions of PoRep with timing assumptions. The assumption is that generation of the replica (hence the <em>Replication</em>) takes some time <em>t</em> that is substantially larger than the time it takes to produce a proof (hence <em>time(Prove)</em>) and the round-trip time (<em>RTT</em>) for sending a challenge and receiving a proof.</p>

<p><strong>Distinguishing Malicious provers</strong>. A malicious prover that does not have <em>R</em>, must obtain it (or generate it), before the <em>Prove</em> step. A verifier can distinguish an honest prover from a malicious prover, since the malicious one will take too long to answer the challenge. A verifier will reject if receiving the proof from the prover takes longer than a timeout (bounded between proving time and replication time).</p>

<h3 id="background-on-zigzag">Background on ZigZag</h3>

<p><em>ZigZag</em> is a specific Proof-of-Replication construction that we use in Filecoin. ZigZag has been designed by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.  In high level, ZigZag ensures that the <em>Replicate</em> step is a slow non-parallelizable sequential process by using some special type of graphs called Depth Robust Graphs (we refer to as &ldquo;DRG&rdquo;).</p>

<p><strong>Encoding using DRGs</strong>. By positioning data blocks into nodes in the DRG, we sequentially encode each node in the graph using its encoded parents. The depth robustness property of these graphs ensure that this process is not likely to be parallelizable.</p>

<p><strong>Layering DRGs</strong>. ZigZag repeates this encoding by layering DRG graphs <code>LAYERS</code> times. The data represented in each DRG layer is the data encoded in the previous layer. We connect different layers using Bipartite Expander Graphs and at each layer, we reverse the graph edges with a technique which we call zigzag. The combination of DRGs, expander graphs and zigzag guarantee the security property of PoRep. The final encoded layer is the final replica.</p>

<p><strong>Generating ZigZag proofs</strong>. Given the following public parameters:</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details)</li>
<li><code>CommD</code> is the Merkle Tree root hash of the input data to the first layer</li>
<li><code>CommRStar</code> is the hash of the concatenation of the <code>ReplicaId</code> and all the <code>CommR</code>s.</li>
<li><code>CommRLast</code> is the hash of the last encoded DRG layer.</li>
</ul>

<p>A ZigZag proof proves that some data whose committment is <code>CommD</code> has been used to run a <code>Replicate</code> algorithm and generated some data whose commitment is <code>CommRLast</code>.</p>

<p>A ZigZag proof consists of a set of challenged DRG nodes (both encoded and unencoded) for each layer, a set of parent nodes for each challenged node and a Merkle tree inclusion proof for each node provided. The verifier can then verify the correct encoding of each node and that the nodes given were consistent with the provers&rsquo; commitments.</p>

<p><strong>Making proofs succinct with SNARKs</strong>: The proof size in the ZigZag is too large for blockchain usage (~100MB), mostly due to the large amount of Merkle tree inclusion proofs required to achieve security. We use SNARKs to generate a proof of knowledge of a correct ZigZag proof. In other words, we implement the ZigZag proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>The SNARK circuit proves that given a Merkle root <code>CommD</code>, <code>CommRLast</code>, and <code>commRStar</code>, the prover knew the correct replicated data at each layer.</p>

<h3 id="porep-in-filecoin">PoRep in Filecoin</h3>

<p>Proof-of-Replication proves that a Storage Miner is dedicating unique storage for each <strong><em>sector</em></strong>. Filecoin Storage Miners collect new clients&rsquo; data in a sector, run a slow encoding process (called <code>Seal</code>) and generate a proof (<code>SealProof</code>) that the encoding was generated correctly.</p>

<p>In Filecoin, PoRep provides two guarantees: (1) <em>space-hardness</em>: Storage Miners cannot lie about the amount of space they are dedicating to Filecoin in order to gain more power in the consensus; (2) <em>replication</em>: Storage Miners are dedicating unique storage for each copy of their clients data.</p>

<p>Glossary:</p>

<ul>
<li><strong><em>sector:</em></strong> a fixed-size block of data of <code>SECTOR_SIZE</code> bytes which generally contains clients&rsquo; data.</li>
<li><strong><em>unsealed sector:</em></strong> a concrete representation (on disk or in memory) of a sector&rsquo;s that follows the &ldquo;Storage Format&rdquo; described in <a href="../client-data#storage-format">Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</li>
<li><strong><em>sealed sector:</em></strong>  a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an <strong><em>unsealed sector</em></strong>. A sector contains one or more <strong><em>pieces</em></strong>.</li>
<li><strong><em>piece:</em></strong> a block of data of at most <code>SECTOR_SIZE</code> bytes which is generally a client&rsquo;s file or part of.</li>
</ul>

<h2 id="zigzag-construction">ZigZag Construction</h2>

<h3 id="public-parameters">Public Parameters</h3>

<p>The following public parameters are used in the ZigZag Replication and Proof Generation algorithms:</p>

<p>TODO: the Appendix should explain why we picked those values</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>SECTOR_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the DRG in bytes</td>
<td align="right"><code>68,719,476,736</code></td>
</tr>

<tr>
<td><code>LAYERS</code></td>
<td><code>uint</code></td>
<td>Number of Depth Robust Graphs stacked layers.</td>
<td align="right"><code>10</code></td>
</tr>

<tr>
<td><code>BASE_DEGREE</code></td>
<td><code>uint</code></td>
<td>In-Degree of each Depth Robust Graph.</td>
<td align="right"><code>5</code></td>
</tr>

<tr>
<td><code>EXPANSION_DEGREE</code></td>
<td><code>uint</code></td>
<td>Degree of each Bipartite Expander Graph to extend dependencies between layers.</td>
<td align="right"><code>8</code></td>
</tr>

<tr>
<td><code>GRAPH_SEED</code></td>
<td><code>uint</code></td>
<td>Seed used for random number generation in <code>baseParents</code>.</td>
<td align="right"><code>TODO</code></td>
</tr>

<tr>
<td><code>NODE_SIZE</code></td>
<td><code>uint</code></td>
<td>Size of each node in bytes.</td>
<td align="right"><code>32B</code></td>
</tr>
</tbody>
</table>

<p>The following constants are computed from the public parameters:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">computation</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>PARENTS_COUNT</code></td>
<td><code>uint</code></td>
<td>Total number of parent nodes</td>
<td align="right"><code>EXPANSION_DEGREE + BASE_DEGREE</code></td>
<td><code>13</code></td>
</tr>

<tr>
<td><code>GRAPH_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the graph</td>
<td align="right"><code>SECTOR_SIZE / NODE_SIZE</code></td>
<td><code>2,147,483,648</code></td>
</tr>

<tr>
<td><code>TREE_DEPTH</code></td>
<td><code>uint</code></td>
<td>Height of the Merkle Tree of a sector</td>
<td align="right"><code>LOG_2(GRAPH_SIZE)</code></td>
<td><code>31</code></td>
</tr>
</tbody>
</table>

<p>The following additional public parameters are required:</p>

<ul>
<li><code>TAPER</code> : <code>Float</code>: Fraction of each layer&rsquo;s challenges by which to reduce next-lowest layer&rsquo;s challenge count.</li>
<li><code>TAPER_LAYERS</code>: <code>uint</code>: Number of layers
<code>Data</code> is a byte array initialized to the content of <strong><em>unsealed sector</em></strong> and will be mutated in-place by the replication process.</li>
</ul>

<h3 id="hash-functions">Hash Functions</h3>

<p>We have describe three hash functions:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>size of input</th>
<th>size of output</th>
<th>construction</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>KDFHash</code></td>
<td>Hash function used as a KDF to derive the key to encode a single node.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>Blake2s-256</code></td>
</tr>

<tr>
<td><code>CommRHash</code></td>
<td>Hash function used to hash all the commitments at every layer (<code>CommR</code>s) to generate <code>CommRStar</code></td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>Blake2s-256</code></td>
</tr>

<tr>
<td><code>RepCompress</code></td>
<td>Collision Resistant Hash function used for the Merkle tree.</td>
<td>2 x <code>32B</code> + integer height</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>

<tr>
<td><code>RepHash</code></td>
<td>Merkle-tree based hash function used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication</td>
<td>TODO</td>
<td><code>32B</code></td>
<td>It uses <code>RepCompress</code></td>
</tr>
</tbody>
</table>

<h4 id="rephash">RepHash</h4>

<p><code>RepHash</code> is Merkle-tree based hash function used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication. The tree is a binary balanced Merkle-tree. The leaves of the Merkle tree are pairs of adjacent nodes.</p>

<p><code>RepHash</code> inputs MUST respect a valid Storage Format.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">node</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uint8</span>

<span class="c1">// Create and return a balanced binary Merkle tree and its root commitment.
</span><span class="c1">// len(leaves) must be a power of 2.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepHash</span><span class="p">(</span><span class="nx">leaves</span> <span class="p">[]</span><span class="nx">node</span><span class="p">)</span> <span class="p">([][]</span><span class="nx">node</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rows</span> <span class="p">=</span> <span class="p">[][]</span><span class="nx">node</span>
    
    <span class="nx">currentRow</span> <span class="o">:=</span> <span class="nx">leaves</span>
    <span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">currentRow</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nx">rows</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">currentRow</span><span class="p">)</span>
        <span class="kd">var</span> <span class="nx">nextRow</span> <span class="p">[]</span><span class="nx">node</span>

        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="nx">left</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="nx">right</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1">// NOTE: Depending on choice of RepCompress, heightPart may be trimmed to fewer than 8 bits.
</span><span class="c1"></span>            <span class="nx">heightPart</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint8</span><span class="p">{</span><span class="nx">height</span><span class="p">}</span>
            
            <span class="nx">input1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">heightPart</span><span class="p">,</span> <span class="nx">left</span><span class="o">...</span><span class="p">)</span>
            <span class="nx">input</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">input1</span><span class="p">,</span> <span class="nx">right</span><span class="o">...</span><span class="p">)</span>
            <span class="nx">hashed</span> <span class="p">=</span> <span class="nf">RepCompress</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">nextRow</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nextRow</span><span class="p">,</span> <span class="nx">hashed</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">currentRow</span> <span class="p">=</span> <span class="nx">nextRow</span>
    <span class="p">}</span>
    <span class="c1">// The tree returned here is just a vector of rows for later use. Its representation is not part of the spec.
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">currentRow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<h3 id="zigzag-graph">ZigZag Graph</h3>

<p>The slow sequential encoding required is enforced by the depth robusness property of the ZigZag graph.</p>

<p><strong>Encoding with ZigZag</strong>: The data from a sector (of size <code>SECTOR_SIZE</code>) is divided in <code>NODE_SIZE</code> nodes (for a total of <code>GRAPH_SIZE</code> nodes) and arranged in a directed acyclic graph. The structure of the graph is used to encode the data sequentially: in order to encode a node, its parents must be encoded (see the &ldquo;Layer Replication&rdquo; section below). We repeat this process for <code>LAYERS</code> layers, where the input to a next layer is the output of the previous one.</p>

<p><strong>Generating the ZigZag graph</strong>: The ZigZag graph is divided in <code>LAYERS</code> layers. Each layer is a directed acyclic graph and it combines a Depth Robust Graph (DRG) and a Bipartite Expander graph.</p>

<p>We provide an algorithm (<code>ZigZag</code>) which computes the parents of a node. In high level, the parents of a node are computed by combining two algorithms: some parents (<code>BASE_DEGREE</code> of them) are computed via the <code>BucketSample</code> algorithm, others (<code>EXPANSION_DEGREE</code> of them) are computer via the <code>Chung</code> algorithm.In addition, every odd layer performs the &ldquo;ZigZag&rdquo; technique which reverts some edges and inverts some nodes.</p>

<h4 id="zigzag-zigzag-graph-algorithm"><code>ZigZag</code>: ZigZag Graph algorithm</h4>

<p>Overview: on even layers, compute the DRG and the Bipartite Expander parents using respectively <code>BucketSample</code> and <code>ChungExpander</code>, on odd layers, compute the inverted DRG parents (using <code>BucketSample</code> on the inverted node: <code>GRAPH_SIZE - node - 1</code> and inverting the resulting parents <code>GRAPH_SIZE - parent -1</code> for each parent) and the reverted Biparate Expander parents (by reverting the edges)</p>

<h5 id="inputs">Inputs</h5>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>node</code></td>
<td>The node for which the parents are being computed</td>
<td><code>uint</code></td>
</tr>

<tr>
<td><code>layer</code></td>
<td>The layer of the ZigZag graph</td>
<td><code>uint</code></td>
</tr>
</tbody>
</table>

<h5 id="outputs">Outputs</h5>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>parents</code></td>
<td>The parents of node <code>node</code> on layer <code>layer</code></td>
<td><code>[PARENTS_COUNT]uint</code></td>
</tr>
</tbody>
</table>

<h5 id="algorithm">Algorithm</h5>

<ul>
<li><p>If the <code>layer</code> is even:</p>

<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Compute <code>expanderParents = ChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>drgParents</code> and <code>expanderParents</code></li>
</ul></li>

<li><p>If the <code>layer</code> is odd:</p>

<ul>
<li>Invert the <code>node</code>: <code>inverted_node = GRAPH_SIZE - inverted_node - 1</code></li>
<li>Compute the inverted DRG parents <code>invertedDRGParents</code>:</li>
<li>Compute <code>drgParents = BucketSample(n)</code></li>
<li>For each <code>parent</code> in <code>drgParents</code>:

<ul>
<li><code>invertedDRGParents.push(GRAPH_SIZE - parent - 1)</code></li>
</ul></li>
<li>Compute the reversed Expander parents: <code>reversedExpanderParents</code>:</li>
<li>Compute <code>reversedExpanderParents = InverseChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>invertedDrgParents</code> and <code>reversedExpanderParents</code></li>
</ul></li>
</ul>

<h5 id="pseudocode">Pseudocode</h5>

<p>We provide below a more succinct representation of the algorithm:</p>

<pre><code>func ZigZag(node uint, layer uint) {

  if layer % 2 == 0 {
      // On even layers
      let drgParents = BucketSample(node)
      let expanderParents = ChungExpander(node)
      return concat(drgParents, expanderParents)
  } else {
    // On odd layers
      
      // Inverting DRG parents
    let inverted_node = GRAPH_SIZE - node - 1
      let drgParents = BucketSample(inverted_node)
      let invertedDrgParents = []
      for i in 0..drgParents.len() {
      invertedDrgParents.push(GRAPH_SIZE - drgParents[i] - 1)
      }
      // Reverting ChungExpander
        let reversedExpanderParents = ReversedChungExpander(node)
      return concat(invertedDrgParents, reversedExpanderParents)
  }
}
</code></pre>

<h5 id="tests">Tests</h5>

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST not be greater than <code>GRAPH_SIZE-1</code> and lower than <code>0</code></li>
<li>If <code>layer</code> is even:

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST be greater than <code>node</code></li>
<li>EXCEPT: if <code>node</code> is <code>0</code>, then all parents MUST be <code>0</code></li>
</ul></li>
<li>if <code>layer</code> is odd:

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST be less than <code>node</code></li>
<li>EXCEPT: if <code>node</code> is <code>GRAPH_SIZE-1</code>, then all parents MUST be <code>GRAPH_SIZE-1</code></li>
</ul></li>
</ul>

<h5 id="time-space-tradeoff">Time-space tradeoff</h5>

<p>Computing the parents using both <code>BucketSample</code> and <code>ChungExpander</code> (and <code>Reverse</code>) for every layer can be an expensive operation, however, this can be avoided by caching the parents. It is important to note that all the odd layers and all the even layers have the same structure.</p>

<h4 id="bucketsample-depth-robust-graphs-algorithm"><code>BucketSample</code>: Depth Robust Graphs algorithm</h4>

<p>This section describes how to compute the &ldquo;base parents&rdquo; of the ZigZag graph, which is the equivalent of computing the parents of a Depth Robust Graph.</p>

<p>The properties of DRG graphs guarantee that a sector has been encoded with a slow, non-parallelizable process. We use the <code>BucketSample</code> algorithm that is based on DRSample (<a href="https://acmccs.github.io/papers/p1001-alwenA.pdf">ABH17</a>) and described in <a href="https://web.stanford.edu/~bfisch/porep_short.pdf">FBGB18</a> and generates a directed acyclic graph of in-degree <code>BASE_DEGREE</code>.</p>

<p><code>BucketSample</code> DRG graphs are random graphs that can be deterministically generated from a seed; different seed lead with high probability to different graphs. In ZigZag, we use the same seed <code>GRAPH_SEED</code> for each layer of the ZigZag graph such that they are all based on the same DRG graph.</p>

<p>The parents of any node can be locally computed without computing the entire graph. We call the parents of a node calculated in this way <em>base parents</em>.</p>

<h5 id="pseudocode-1">Pseudocode</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BucketSample</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[</span><span class="nx">BASE_DEGREE</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">node</span> <span class="p">{</span>
        <span class="c1">// Special case for the first node, it self references.
</span><span class="c1"></span>        <span class="c1">// Special case for the second node, it references only the first one.
</span><span class="c1"></span>        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">BASE_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="p">}</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nx">rng</span> <span class="o">:=</span> <span class="nx">ChaChaRng</span><span class="p">.</span><span class="nf">from_seed</span><span class="p">(</span><span class="nx">GRAPH_SEED</span><span class="p">)</span>

            <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">BASE_DEGREE</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// iterate over m meta nodes of the ith real node
</span><span class="c1"></span>                <span class="c1">// simulate the edges that we would add from previous graph nodes
</span><span class="c1"></span>                <span class="c1">// if any edge is added from a meta node of jth real node then add edge (j,i)
</span><span class="c1"></span>                <span class="nx">logi</span> <span class="o">:=</span> <span class="nf">floor</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span><span class="p">))</span>
                <span class="nx">j</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nf">gen</span><span class="p">()</span> <span class="o">%</span> <span class="nx">logi</span>
                <span class="nx">jj</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span> <span class="o">+</span> <span class="nx">k</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="nx">backDist</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nf">gen_range</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="nx">jj</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nx">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">out</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">backDist</span><span class="p">)</span> <span class="o">/</span> <span class="nx">BASE_DEGREE</span>

                <span class="c1">// remove self references and replace with reference to previous node
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">out</span> <span class="o">==</span> <span class="nx">node</span> <span class="p">{</span>
                    <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">node</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">out</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">sort</span><span class="p">(</span><span class="nx">parents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="chungexpander-bipartite-expander-graphs"><code>ChungExpander</code>: Bipartite Expander Graphs</h4>

<p>TODO: explain why we link nodes in the current layer</p>

<p>Every node in a layer has <code>EXPANSION_DEGREE</code> parents that are generated via the following algorithm.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChungExpander</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">parents</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">)</span>

    <span class="nx">feistelKeys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// TODO
</span><span class="c1"></span>  
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span> <span class="o">+</span> <span class="nx">i</span>
    <span class="nx">transformed</span> <span class="o">:=</span> <span class="nf">feistelPermute</span><span class="p">(</span><span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">feistelKeys</span><span class="p">)</span>
    <span class="nx">other</span> <span class="o">:=</span> <span class="nx">transformed</span> <span class="o">/</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="k">if</span> <span class="nx">other</span> <span class="p">&lt;</span> <span class="nx">node</span> <span class="p">{</span>
      <span class="nx">parents</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">other</span>
      <span class="nx">p</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ReverseChungExpander</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">parents</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">)</span>

    <span class="nx">feistelKeys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// TODO
</span><span class="c1"></span>  
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span> <span class="o">+</span> <span class="nx">i</span>
    <span class="nx">transformed</span> <span class="o">:=</span> <span class="nf">invertFeistelPermute</span><span class="p">(</span><span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">feistelKeys</span><span class="p">)</span>
    <span class="nx">other</span> <span class="o">:=</span> <span class="nx">transformed</span> <span class="o">/</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="k">if</span> <span class="nx">other</span> <span class="p">&gt;</span> <span class="nx">node</span> <span class="p">{</span>
      <span class="nx">parents</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">other</span>
      <span class="nx">p</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="time-space-tradeoff-1">Time-Space tradeoff</h5>

<p>Computing these parents can be expensive (especially due to the hashing required by the Feistel algorithm). A miner can trade this computation by storing the expansion parents and the reversed expansion parents.</p>

<h5 id="feistel-construction">Feistel construction</h5>

<p>We use three rounds of Feistel as a permutation to generate the parents of the Bipartite Expander graph.</p>

<p>TODO: Add <code>FEISTEL_ROUNDS</code> and <code>FEISTEL_BYTES</code> (or find its definitions)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">numElements</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">u</span> <span class="o">:=</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>

    <span class="nx">while</span> <span class="nx">u</span> <span class="o">&gt;=</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">u</span> <span class="p">=</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// Since we are representing `numElements` using an even number of bits,
</span><span class="c1"></span>    <span class="c1">// that can encode many values above it, so keep repeating the operation
</span><span class="c1"></span>    <span class="c1">// until we land in the permitted range.
</span><span class="c1"></span>
    <span class="k">return</span> <span class="nx">u</span>
<span class="p">}</span>

<span class="c1">// Inverts the `permute` result to its starting value for the same `key`.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">invertPermute</span><span class="p">(</span><span class="nx">numElements</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">u</span> <span class="o">:=</span> <span class="nf">feistelDecode</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>

    <span class="nx">while</span> <span class="nx">u</span> <span class="o">&gt;=</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">u</span> <span class="p">=</span> <span class="nf">feistelDecode</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">keys</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">u</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span> <span class="o">:=</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
        <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">left</span> <span class="p">^</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span>  <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="p">|</span> <span class="nx">right</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">numElements</span> <span class="o">:=</span> <span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="nx">nextPow4</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">halfBits</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nx">while</span> <span class="nx">nextPow4</span> <span class="p">&lt;</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">nextPow4</span> <span class="o">*=</span> <span class="mi">4</span>
        <span class="nx">halfBits</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="nx">rightMask</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">leftMask</span> <span class="p">=</span> <span class="nx">rightMask</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span>

    <span class="nx">right</span> <span class="o">:=</span> <span class="nx">index</span> <span class="o">&amp;</span> <span class="nx">rightMask</span>
    <span class="nx">left</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&amp;</span> <span class="nx">leftMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">halfBits</span>

    <span class="k">return</span>  <span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Round function of the Feistel network: `F(Ri, Ki)`. Joins the `right`
</span><span class="c1">// piece and the `key`, hashes it and returns the lower `uint32` part of
</span><span class="c1">// the hash filtered trough the `rightMask`.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">right</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">rightMask</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="p">[</span><span class="nx">FEISTEL_BYTES</span><span class="p">]</span><span class="kt">uint</span>

    <span class="kd">var</span> <span class="nx">r</span> <span class="kt">uint</span>
    <span class="k">if</span> <span class="nx">FEISTEL_BYTES</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

        <span class="nx">hash</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

        <span class="nx">r</span> <span class="p">=</span>   <span class="nx">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

        <span class="nx">hash</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

        <span class="nx">r</span> <span class="p">=</span>   <span class="nx">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nx">rightMask</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">feistelDecode</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span> <span class="o">:=</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">reversed</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span> <span class="p">^</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">keys</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">),</span> <span class="nx">left</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="p">|</span> <span class="nx">right</span>
<span class="p">}</span></code></pre></div>
<h2 id="replication">Replication</h2>

<blockquote>
<p>The Replication phase turns an <em>unsealed sector</em> into a <em>sealed sector</em></p>
</blockquote>

<p>Before running the <code>Replicate</code> algorithm, the prover must ensure that the sector is correctly formatted with a valid with the &ldquo;Storage Format&rdquo; described in <a href="../client-data#storage-format">Filecoin Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</p>

<p>TODO: inputs are missing</p>

<p>The Replication Algorithm  proceeds as follows:</p>

<ul>
<li><p>Calculate <code>ReplicaID</code> using <code>Hash</code> (Blake2s):</p>

<pre><code>ReplicaID := Hash(ProverID || SectorID || ticket)
</code></pre></li>

<li><p>Perform <code>RepHash</code> on <code>Data</code> to yield <code>CommD</code> and <code>TreeD</code>:</p>

<pre><code>CommD, TreeD = RepHash(data)
</code></pre></li>
</ul>

<p>For each of <code>LAYERS</code> layers, <code>l</code>, perform one <strong><em>Layer Replication</em></strong>, yielding a replica, tree, and commitment (<code>CommR_&lt;l&gt;</code>) per layer:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">let</span> <span class="nx">layer_replicas</span> <span class="p">=</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">][</span><span class="nx">nodes</span><span class="p">]</span><span class="kt">uint8</span>
<span class="nx">let</span> <span class="nx">layer_trees</span> <span class="p">=</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">MerkleTree</span>
<span class="nx">let</span> <span class="nx">CommRs</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">commitment</span>

<span class="nx">let</span> <span class="nx">layer</span> <span class="p">=</span> <span class="nx">data</span>
<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="mf">0.</span><span class="p">.</span><span class="nx">layers</span> <span class="p">{</span>
    <span class="nx">let</span> <span class="nx">layer_replica</span> <span class="p">=</span> <span class="nf">ReplicateLayer</span><span class="p">(</span><span class="nx">layer</span><span class="p">)</span>
    <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">=</span> <span class="nx">layer_replica</span>
    <span class="nx">CommRs</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">layers_trees</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">=</span> <span class="nf">RepTree</span><span class="p">(</span><span class="nx">layer_replica</span><span class="p">)</span>
    <span class="nx">layer</span> <span class="p">=</span> <span class="nx">layer_replica</span>
<span class="p">}</span></code></pre></div>
<p>The replicated data is the output of the final <strong><em>Layer Replication</em></strong>,<code>layer_replicas[layers-1]</code>.
Set <code>CommRLast</code> to be  <code>CommR_&lt;Layers&gt;</code>.
Set <code>CommRStar</code> to be <code>CommRHash(ReplicaID || CommR_0 || CommR_&lt;i&gt; || ... || CommRLast)</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Replica</span> <span class="o">:=</span> <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="nx">CommRLast</span> <span class="p">:</span><span class="o">-</span> <span class="nx">CommRs</span><span class="p">[</span><span class="nx">layers</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nx">CommRStar</span> <span class="o">:=</span> <span class="nf">CommRHash</span><span class="p">(</span><span class="nx">replicaID</span><span class="p">,</span> <span class="o">...</span><span class="nx">CommRs</span><span class="p">)</span></code></pre></div>
<h3 id="layer-replication">Layer Replication</h3>

<p>TODO: Define <code>Graph</code>. We need to decide if this is an object we&rsquo;ll explicitly define or if its properties (e.g., <code>GRAPH_SIZE</code>) are just part of the replication parameters and all the functions just refer to the <em>same</em> graphs being manipulated across the entire replication process. (At the moment I&rsquo;ve avoided defining a <code>Graph</code> structure as in other specs I didn&rsquo;t see any object methods, just standalone functions.)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">transformAndReplicateLayers</span><span class="p">(</span><span class="nx">slothIter</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span>
    <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">([]</span><span class="nx">Domain</span><span class="p">,</span> <span class="p">[]</span><span class="nx">Tree</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">taus</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">Domain</span>
    <span class="kd">var</span> <span class="nx">auxs</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">Tree</span>
    <span class="kd">var</span> <span class="nx">sortedTrees</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">Tree</span>

    <span class="k">for</span> <span class="nx">layer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">LAYERS</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">treeData</span> <span class="o">:=</span> <span class="nf">merkleTree</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
        <span class="nx">sortedTrees</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">treeData</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">layer</span> <span class="p">&lt;</span> <span class="nx">LAYERS</span> <span class="p">{</span>
            <span class="nf">vdeEncode</span><span class="p">(</span><span class="nx">slothIter</span><span class="p">,</span> <span class="nx">replicaId</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">zigzag</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">previousCommr</span> <span class="o">:=</span> <span class="kc">nil</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">replicaTree</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sortedTrees</span> <span class="p">{</span>
        <span class="nx">commR</span> <span class="o">:=</span> <span class="nx">replicaTree</span><span class="p">.</span><span class="nf">root</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">previousCommr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">commD</span> <span class="o">:=</span> <span class="nx">previousCommr</span>
            <span class="nx">tau</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">commR</span><span class="p">,</span> <span class="nx">commD</span><span class="p">)</span>
            <span class="nx">taus</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">tau</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">auxs</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">replicaTree</span><span class="p">);</span>
        <span class="nx">previousCommr</span> <span class="p">=</span> <span class="nx">commR</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="nx">taus</span><span class="p">,</span> <span class="nx">auxs</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Note: The function <code>zigzag</code> just inverts an internal <code>bool</code> that tracks whether the <code>graphIsReversed()</code> or not.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">vdeEncode</span><span class="p">(</span><span class="nx">slothIter</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">replicaId</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">parents</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">]</span><span class="kt">uint</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">GRAPH_SIZE</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">node</span> <span class="kt">uint</span>
        <span class="k">if</span> <span class="p">!</span><span class="nf">graphIsReversed</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">node</span> <span class="p">=</span> <span class="nx">n</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If the graph is reversed, traverse in reverse order.
</span><span class="c1"></span>            <span class="nx">node</span> <span class="p">=</span> <span class="nx">GRAPH_SIZE</span> <span class="o">-</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">}</span>

        <span class="nx">parents</span> <span class="p">=</span> <span class="nf">parents</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>

        <span class="nx">key</span> <span class="o">:=</span> <span class="nf">KDFHash</span><span class="p">(</span><span class="nx">replicaId</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">parents</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

        <span class="nx">start</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">NODE_SIZE</span>
        <span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">NODE_SIZE</span><span class="p">;</span>
        <span class="nx">nodeData</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">])</span>
        <span class="nx">encoded</span> <span class="o">:=</span> <span class="nf">slothEncode</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">nodeData</span><span class="p">,</span> <span class="nx">slothIter</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span> <span class="p">=</span> <span class="nx">encoded</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h2 id="proof-generation">Proof Generation</h2>

<p>Overview:</p>

<ul>
<li>Challenge Derivation</li>
<li>Proof Generation</li>
<li>Circuit Proof Generation</li>
</ul>

<p>TODO: write a single algorithm which includes the spec below</p>

<h3 id="challenge-derivation">Challenge Derivation</h3>

<p>This is the Fiat-Shamir transform that turns the interactive Proof-of-Replication into non-interactive in the Random Oracle model.</p>

<p>TODO: define <code>Domain</code> (for practical purposes a <code>uint</code>) and <code>LayerChallenges</code> (or find existing definition).</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TODO: we should replace the word commitment with the word seed, this will be more interactive porep friendly
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeriveChallenges</span><span class="p">(</span><span class="nx">challenges</span> <span class="nx">LayerChallenges</span><span class="p">,</span> <span class="nx">layer</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">leaves</span> <span class="kt">uint</span><span class="p">,</span>
    <span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">commitment</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint</span> <span class="p">{</span>

    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">challenges</span><span class="p">.</span><span class="nf">ChallengesForLayer</span><span class="p">(</span><span class="nx">layer</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">derivedChallenges</span> <span class="p">[</span><span class="nx">n</span><span class="p">]</span><span class="kt">uint</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">bytes</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">replicaId</span><span class="p">)</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">commitment</span><span class="p">));</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">layer</span><span class="p">);</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nf">toLittleEndian</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span> <span class="nx">k</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

        <span class="c1">// For now, we cannot try to prove the first or last node, so make 
</span><span class="c1"></span>        <span class="c1">// sure the challenge can never be 0 or leaves - 1.
</span><span class="c1"></span>        <span class="nx">big_mod_challenge</span> <span class="o">:=</span> <span class="nf">blake2s</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nx">leaves</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nx">derivedChallenges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">big_mod_challenge</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h3 id="challenge-generation">Challenge Generation</h3>

<p>TODO: we may need to remove this section.</p>

<p>Calculate <code>LAYER_CHALLENGES : [LAYERS]uint</code>: Number of challenges per layer. (This will be passed to the ZigZag circuit proof.)</p>

<p>Derive challenges for each layer (call <code>DeriveChallenges()</code>).</p>

<h3 id="witness-generation">Witness Generation</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">let</span> <span class="nx">layer_proofs</span> <span class="p">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="mf">0.</span><span class="p">.</span><span class="nx">LAYERS</span> <span class="p">{</span>
  <span class="nx">let</span> <span class="nx">replica</span> <span class="p">=</span> <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="nx">let</span> <span class="nx">replica_tree</span> <span class="p">=</span> <span class="nx">layer_trees</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  
  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="nf">derive_challenges</span><span class="p">(</span><span class="nx">LAYER_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
    <span class="nx">data_inclusion_proof</span> <span class="p">=</span> <span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataTree</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="p">&gt;)</span>
    <span class="nx">replica_inclusion_proof</span> <span class="p">=</span> <span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">replica</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">replica_tree</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;)</span> <span class="o">||</span> <span class="nx">FAIL</span><span class="c1">// Prove the replica. TODO explain replica[].
</span><span class="c1"></span>    
    <span class="c1">// *** let kdf_preimage = [replica_id] ***
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">parent_replica_inclusion_proofs</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="nf">parents</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// *** kdf_preimage.push(p)***
</span><span class="c1"></span>      <span class="nx">parent_replica_inclusion_proofs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;))</span>
    <span class="p">}</span>
    <span class="c1">// *** let key = kdf(kdf_preimage); ***
</span><span class="c1"></span>    
    <span class="c1">// *** encode(key, data[c]) == replica[c]
</span><span class="c1"></span>    <span class="c1">// *** We don&#39;t actually need to encode in the proof. ***
</span><span class="c1"></span>    <span class="c1">// TODO: move this ***stuff*** to verification.
</span><span class="c1"></span>
    <span class="nx">layer_proof</span><span class="p">.</span><span class="nf">push</span><span class="p">((</span><span class="nx">data_inclusion_proof</span><span class="p">,</span> <span class="nx">replication_inclusion_proof</span><span class="p">,</span> <span class="nx">parent_replica_inclusion_proofs</span><span class="p">))</span>    
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">return</span> <span class="nx">layer_proofs</span><span class="p">,</span> <span class="nx">CommRstar</span><span class="p">,</span> <span class="nx">CommRLast</span></code></pre></div>
<p>TODO: reconcile outputs of non-circuit proof with inputs to circuit proof.</p>

<h3 id="snark-proof-generation">SNARK Proof Generation</h3>

<p>See <a href="../zigzag-circuit"># ZigZag: Offline PoRep Circuit Spec</a> for details of Circuit Proof Generation.</p>

<h2 id="appendex">Appendex</h2>

<h3 id="layer-challenge-counts">Layer Challenge Counts</h3>

<p>TODO: define <code>Challenge</code> (or find existing definition)</p>

<p>TODO: we should just list current parameters and show this as a calculation for correctness, this should not mandatory to implement.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChallengesForLayer</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">Challenge</span><span class="p">,</span> <span class="nx">layer</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>

    <span class="k">switch</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
      <span class="c1">// TODO: remove ambiguity, there should not be a &#34;fixed&#34; case
</span><span class="c1"></span>        <span class="k">case</span> <span class="nx">Fixed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Count</span>
        <span class="k">case</span> <span class="nx">Tapered</span><span class="p">:</span>
      <span class="c1">// TODO: current calculation is incorrect and does not match claim6 from Fisch2019, it should look more like: https://observablehq.com/d/bbabac1947b79011#gen_zigzag_taper
</span><span class="c1"></span>            <span class="nf">assert</span><span class="p">(</span><span class="nx">layer</span> <span class="p">&lt;</span> <span class="nx">LAYERS</span><span class="p">)</span>
            <span class="nx">l</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">LAYERS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nx">layer</span>
            <span class="nx">r</span> <span class="o">:=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nx">TAPER</span><span class="p">;</span>
            <span class="nx">t</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">TAPER_LAYERS</span><span class="p">)</span>

            <span class="nx">totalTaper</span> <span class="o">:=</span> <span class="nf">pow</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

            <span class="nx">calculated</span> <span class="o">:=</span> <span class="nf">ceil</span><span class="p">(</span><span class="nx">totalTaper</span> <span class="o">*</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>

            <span class="c1">// Although implied by the call to `ceil()` above, be explicit
</span><span class="c1"></span>            <span class="c1">// that a layer cannot contain 0 challenges.
</span><span class="c1"></span>            <span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">calculated</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
</article>

      
<div class="align-center book-git-footer justify-end">
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/zigzag-porep.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#proof-of-replication">Proof-of-Replication</a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#background-on-proof-of-replication">Background on Proof-of-Replication</a>
<ul>
<li><a href="#time-bounded-proof-of-replication">Time-bounded Proof-of-Replication</a></li>
</ul></li>
<li><a href="#background-on-zigzag">Background on ZigZag</a></li>
<li><a href="#porep-in-filecoin">PoRep in Filecoin</a></li>
</ul></li>
<li><a href="#zigzag-construction">ZigZag Construction</a>
<ul>
<li><a href="#public-parameters">Public Parameters</a></li>
<li><a href="#hash-functions">Hash Functions</a>
<ul>
<li><a href="#rephash">RepHash</a></li>
</ul></li>
<li><a href="#zigzag-graph">ZigZag Graph</a>
<ul>
<li><a href="#zigzag-zigzag-graph-algorithm"><code>ZigZag</code>: ZigZag Graph algorithm</a>
<ul>
<li><a href="#inputs">Inputs</a></li>
<li><a href="#outputs">Outputs</a></li>
<li><a href="#algorithm">Algorithm</a></li>
<li><a href="#pseudocode">Pseudocode</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#time-space-tradeoff">Time-space tradeoff</a></li>
</ul></li>
<li><a href="#bucketsample-depth-robust-graphs-algorithm"><code>BucketSample</code>: Depth Robust Graphs algorithm</a>
<ul>
<li><a href="#pseudocode-1">Pseudocode</a></li>
</ul></li>
<li><a href="#chungexpander-bipartite-expander-graphs"><code>ChungExpander</code>: Bipartite Expander Graphs</a>
<ul>
<li><a href="#time-space-tradeoff-1">Time-Space tradeoff</a></li>
<li><a href="#feistel-construction">Feistel construction</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#replication">Replication</a>
<ul>
<li><a href="#layer-replication">Layer Replication</a></li>
</ul></li>
<li><a href="#proof-generation">Proof Generation</a>
<ul>
<li><a href="#challenge-derivation">Challenge Derivation</a></li>
<li><a href="#challenge-generation">Challenge Generation</a></li>
<li><a href="#witness-generation">Witness Generation</a></li>
<li><a href="#snark-proof-generation">SNARK Proof Generation</a></li>
</ul></li>
<li><a href="#appendex">Appendex</a>
<ul>
<li><a href="#layer-challenge-counts">Layer Challenge Counts</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
